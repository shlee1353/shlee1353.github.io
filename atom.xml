<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ryan Lee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shlee1353.github.io/"/>
  <updated>2019-07-04T10:55:51.354Z</updated>
  <id>https://shlee1353.github.io/</id>
  
  <author>
    <name>Ryan Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>앵귤러(Angular) 라이프사이클 기초 이해하기</title>
    <link href="https://shlee1353.github.io/2019/07/04/angular-lifecycle-hooks/"/>
    <id>https://shlee1353.github.io/2019/07/04/angular-lifecycle-hooks/</id>
    <published>2019-07-04T10:54:29.000Z</published>
    <updated>2019-07-04T10:55:51.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="생명주기-life-cycle"><a href="#생명주기-life-cycle" class="headerlink" title="생명주기(life cycle)"></a>생명주기(life cycle)</h2><p>컴포넌트와 지시자는 <strong>생명주기(life cycle)</strong> 를 가집니다. 생명주기란, 컴포넌트나 지시자가 생성되고 파괴될 때까지의 일련의 과정을 말합니다. 생명주기 안에서는 특정 시점에 훅 메서드(hook method)를 호출할 수 있습니다. 예를들어, 컴포넌트와 지시자가 초기화되면 ngOnInit() 훅 메서드가 호출됩니다. 만약 이 시점에 실행할 내용이 있다면 컴포넌트 클래스 내에서 ngOnInit() 훅 메서드를 선언하면 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">    ngOnInit() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="생명주기-시퀀스"><a href="#생명주기-시퀀스" class="headerlink" title="생명주기 시퀀스"></a>생명주기 시퀀스</h2><p>훅 메서드는 호출될 때 일정한 순서로 호출됩니다. 이처럼 일정한 순서로 호출되는 과정을 <strong>생명주기 시퀀스(lifecycle sequence)</strong> 라고 합니다. 아래와 같은 순서로 이루어집니다. 생명주기 시퀀스는 초기화 시점, 상태 체크 시점, 이벤트 시점으로 다시 나뉩니다.</p><ol><li>ngOnChanges</li><li>ngOnInit</li><li>ngDoCheck</li></ol><hr><ol><li>ngAfterContentInit</li><li>ngAfterContentChecked</li><li>ngAfterViewInit</li><li>ngAfterViewChecked</li></ol><hr><ol><li>ngOnDestroy</li></ol><p><strong>초기화</strong></p><ul><li>ngOnInit() : 컴포넌트나 지시자가 생성될 때 호출되는 메서드. 생명주기의 초기화 시점입니다.</li><li>ngAfterContentInit() : 외부 콘텐츠가 컴포넌트 뷰로 들어갔을 때 호출</li><li>ngAfterViewInit() : 컴포넌트 뷰와 자식 뷰가 초기화되고 나서 호출</li></ul><p><strong>상태체크</strong></p><ul><li>ngDoCheck() 메서드가 호출되고 나서 ngAfterViewChecked() 가 호출되기까지 콘텐츠와 뷰에 대한 상태 점검이 진행되는 때를 말합니다. </li><li><p><strong>콘텐츠</strong> : 컴포넌트가 선언될 때 내부 엘리먼트에 선언한 엘리먼트의 속성값을 말합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent [prop]=<span class="string">".."</span>&gt;</span><br><span class="line">    &lt;child name=<span class="string">""</span>&gt;&lt;/child&gt; <span class="comment">// 콘텐츠</span></span><br><span class="line">&lt;<span class="regexp">/parent&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Content projection(transclusion)</strong> : 컴포넌트 외부에서 HTML을 가져와 컴포넌트 내부에 원하는 위치에 추가함. Content projection을 의도하지 않았다면 콘텐츠를 컴포넌트 사이에 절대 넣지 마세요.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AfterContentParentComponent</span></span><br><span class="line"><span class="string">`&lt;after-content&gt;</span></span><br><span class="line"><span class="string">   &lt;my-child&gt;&lt;/my-child&gt;</span></span><br><span class="line"><span class="string"> &lt;/after-content&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AfterContentComponent</span></span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;-- projected content begins --&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;ng-content&gt;&lt;/ng-content&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;-- projected content ends --&lt;/div&gt;`</span></span><br></pre></td></tr></table></figure></li><li><p><strong>뷰</strong> : 컴포넌트 내부 탬플릿에 선언한 지시자의 상태</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: <span class="string">'parent'</span>,</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;my-click id="1" *ngIf="status"&gt;&lt;/my-click&gt;  // 지시자</span></span><br><span class="line"><span class="string">    &lt;my-click id="2" *ngIf="status"&gt;&lt;/my-click&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>이벤트 시점</strong></p><ul><li><p>컴포넌트가 초기화될 때는 ngOnInit() 메서드가 먼저 호출되지만 컴포넌트나 지시자에서 속성 바인딩에 의한 이벤트가 발생하면 ngOnChanges() 가 호출되고 나서 ngOnInit() 이 호출됩니다. ngOnChanges() 메서드는 현재 상태값(currentValue)과 이전 상태값(previousValue)을 확인할 수 있는 SimpleChanges 객체를 받습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleChanges 사용법</span></span><br><span class="line"><span class="keyword">import</span> &#123;Component, OnChanges, SimpleChanges &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line">ngOnChanges(changes: SimpleChanges) &#123;</span><br><span class="line">    changes.prop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ngOnDestroy()는 컴포넌트나 지시자를 제거할 때 실행됩니다.</p></li></ul><h2 id="컴포넌트-생명주기"><a href="#컴포넌트-생명주기" class="headerlink" title="컴포넌트 생명주기"></a>컴포넌트 생명주기</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmp-lifecycle</span><br><span class="line">    ㄴ child-cmp.component.ts</span><br><span class="line">    ㄴ cmp-lifecycle.component.ts</span><br><span class="line">    ㄴ my-cmp.component.ts</span><br><span class="line">    ㄴ window.directive.ts</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child-cmp.component.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component, Input, ContentChild, ViewChild, OnChanges, DoCheck, OnInit, AfterContentInit, AfterContentChecked, AfterViewInit, AfterViewChecked, OnDestroy &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MyCmp &#125; <span class="keyword">from</span> <span class="string">'./my-cmp.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Window &#125; <span class="keyword">from</span> <span class="string">'./window.directive'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: <span class="string">'child-cmp'</span>,</span><br><span class="line">    template: <span class="string">`&lt;input type="text" [(ngModel)]="message" placeholder="바인딩 있음"&gt; &lt;input type="text" placeholder="바인딩 없음"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // window 지시자는 ngif 상태에 따라 상태값을 결정</span></span><br><span class="line"><span class="string">    &lt;window id="1" *ngIf="shouldShow"&gt;&lt;/window&gt;</span></span><br><span class="line"><span class="string">    &lt;window id="2" *ngIf="!shouldShow"&gt;&lt;/window&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;button (click)="toggle()"&gt;View 상태변경&lt;/button&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// implements 키워드를 이용해 컴포넌트 클래스에 훅을 구현</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildCmp</span> <span class="title">implements</span> <span class="title">OnChanges</span>, <span class="title">DoCheck</span>, <span class="title">OnInit</span>, <span class="title">AfterContentInit</span>, <span class="title">AfterContentChecked</span>, <span class="title">AfterViewInit</span>, <span class="title">AfterViewChecked</span>, <span class="title">OnDestroy</span> </span>&#123;</span><br><span class="line">    message: string = <span class="string">""</span>;</span><br><span class="line">    oldMessage: string = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123; <span class="built_in">console</span>.log(<span class="string">"\n1-컴포넌트 : constructor()"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    @Input()</span><br><span class="line">    set prop(name: string) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"@Input prop() 세터 메서드 호출"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnChanges() &#123; <span class="built_in">console</span>.log(<span class="string">"2--컴포넌트 : ngOnChanges()"</span>); &#125;</span><br><span class="line">    ngOnInit() &#123; <span class="built_in">console</span>.log(<span class="string">"3---컴포넌트 : ngOnInit()"</span>); &#125;</span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"4----컴포넌트 : ngDoCheck()"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.message != <span class="keyword">this</span>.oldMessage) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"4----컴포넌트 : ngDoCheck()에서 변화감지"</span>);</span><br><span class="line">            <span class="keyword">this</span>.oldMessage = <span class="keyword">this</span>.message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @ContentChild 장식자를 이용해 child-cmp의 자식 엘리먼트인 my-cmp 컴포넌트에 선언된 속성값을 받음</span></span><br><span class="line">    @ContentChild(MyCmp) myCmp: MyCmp;</span><br><span class="line">    oldMyCmpId: any;</span><br><span class="line"></span><br><span class="line">    ngAfterContentInit() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"5-----컴포넌트 : ngAfterContentInit()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.oldMyCmpId = <span class="keyword">this</span>.myCmp.value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ngAfterContentChecked() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"6------컴포넌트 : ngAfterContentChecked()"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.oldMyCmpId != <span class="keyword">this</span>.myCmp.value) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"6------컴포넌트 : ngAfterContentChecked()에서 변화감지"</span>);</span><br><span class="line">            <span class="keyword">this</span>.oldMyCmpId = <span class="keyword">this</span>.myCmp.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldShow = <span class="literal">true</span>;</span><br><span class="line">    toggle() &#123; <span class="keyword">this</span>.shouldShow = !<span class="keyword">this</span>.shouldShow; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query for a VIEW child of type `Window`</span></span><br><span class="line">    @ViewChild(Window) <span class="built_in">window</span>;</span><br><span class="line">    oldWindowId: any;</span><br><span class="line"></span><br><span class="line">    ngAfterViewInit() &#123;</span><br><span class="line">        <span class="comment">// viewChild is set after the view has been initialized</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"7-------컴포넌트 : ngAfterViewInit()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.oldWindowId = <span class="keyword">this</span>.window.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngAfterViewChecked() &#123;</span><br><span class="line">        <span class="comment">// viewChild is updated after the view has been checked</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"8--------컴포넌트 : ngAfterViewChecked()"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.oldWindowId != <span class="keyword">this</span>.window.id) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"8--------컴포넌트 : ngAfterViewChecked()에서 변화감지"</span>);</span><br><span class="line">            <span class="keyword">this</span>.oldWindowId = <span class="keyword">this</span>.window.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ngOnDestroy() &#123; <span class="built_in">console</span>.log(<span class="string">"9---------컴포넌트 : ngOnDestroy()"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my-cmp.component.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125;  <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: <span class="string">'my-cmp'</span>,</span><br><span class="line">    template: <span class="string">``</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCmp</span> </span>&#123;</span><br><span class="line">    @Input() value: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmp-lifecycle.component.ts</span></span><br><span class="line"><span class="comment">// cmp-lifecycle은 my-cmp 컴포넌트를 콘텐츠로 가진다</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: <span class="string">'cmp-lifecycle'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button (click)="toggle()"&gt;Content 상태변경&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)="isShow=!isShow"&gt;&#123;&#123;isShow==false?'컴포넌트 추가':'컴포넌트 삭제'&#125;&#125;&lt;/button&gt;    </span></span><br><span class="line"><span class="string">    &lt;br&gt;</span></span><br><span class="line"><span class="string">    &lt;child-cmp *ngIf="isShow" [prop]="shouldShow"&gt;</span></span><br><span class="line"><span class="string">        &lt;my-cmp value="&#123;&#123;shouldShow&#125;&#125;"&gt;&lt;/my-cmp&gt;</span></span><br><span class="line"><span class="string">    &lt;/child-cmp&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CmpLifecycleComponent</span> </span>&#123;</span><br><span class="line">    isShow: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    shouldShow = <span class="literal">true</span>;</span><br><span class="line">    toggle() &#123; <span class="keyword">this</span>.shouldShow = !<span class="keyword">this</span>.shouldShow; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="콘텐츠-훅-vs-뷰-훅"><a href="#콘텐츠-훅-vs-뷰-훅" class="headerlink" title="콘텐츠 훅 vs. 뷰 훅"></a>콘텐츠 훅 vs. 뷰 훅</h3><p>콘텐츠 훅과 뷰 훅은 매우 유사하지만 분명한 차이점이 있습니다.</p><ul><li>AfterContent 훅은 ContentChildren 을 고려합니다 (컴포넌트 안으로 투영된 자식 컴포넌트)</li><li>AfterView 훅은 ViewChildren 을 고려합니다 (자식 컴포넌트로 컴포넌트 템플릿 안에 엘리먼트 태그로 존재함)</li></ul><h3 id="컴포넌트-생명주기-콘텐츠-훅"><a href="#컴포넌트-생명주기-콘텐츠-훅" class="headerlink" title="컴포넌트 생명주기 (콘텐츠 훅)"></a>컴포넌트 생명주기 (콘텐츠 훅)</h3><ul><li>초기값을 확인해보면 shouldShow = true, isShow = false 입니다.</li><li><strong>Content  상태변경</strong> 클릭시, shouldShow = true, false 전환되지만, 외부 뷰의 표시를 결정하지 않기 때문에 훅 메서드를 호출하지 않습니다.</li><li><strong>컴포넌트 추가</strong> 를 클릭하면, isShow가 true값으로 변하면서 child-cmp가 화면에 그려지기 때문에 초기 출력 로그를 확인할 수 있습니다.</li><li>컴포넌트 시퀀스 생명주기가 나타나고 (1)-(8), child-cmp 컴포넌트 내부에 ngModel 바인딩이 일어나 (4)-(8) 훅에 대한 로그 결과 출력.</li><li>(4)~(8) 로그가 출력된 이유는 child-cmp 컴포넌트 내부에 ngModel 바인딩이 일어났기 때문입니다.</li><li>현재까지의 상태값을 확인해보면, shouldShow = true, isShow = true, this.oldMyCmpId = true, this.myCmp.value = true 입니다.</li><li><p>이제 다시 <strong>Content  상태변경</strong> 을 클릭하면 아래와같은 출력 로그를 확인할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Input prop() 세터 메서드 호출</span><br><span class="line">2--컴포넌트 : ngOnChanges()</span><br><span class="line">4----컴포넌트 : ngDoCheck()</span><br><span class="line">6------컴포넌트 : ngAfterContentChecked()</span><br><span class="line">6------컴포넌트 : ngAfterContentChecked()에서 변화감지</span><br><span class="line">8--------컴포넌트 : ngAfterViewChecked()</span><br></pre></td></tr></table></figure></li><li><p><strong>Content 상태변경</strong> 을 클릭할 때 shouldShow 값이 바뀌면서 속성바인딩 [prop]=”shouldShow” 의 상태가 변경되면서 이를 @Input() set prop(name: string) {…} 에서 받은 뒤 ngOnChanges() 호출</p></li><li>child-cmp 엘리먼트의 [prop] 상태가 변경되었기 때문에 상태점검을 히기위해 ngDoCheck() 호출</li><li>my-cmp 엘리먼트의 속성값이 바뀐걸 확인하기 위해, 이전값과 새로운값을 비교한뒤 “ngAfterContentChecked()에서 감지변화” 호출. 이때 my-cmp의 속성값은 <strong>@ContentChild</strong>(MyCmp) myCmp: MyCmp; 로 받아옵니다.</li></ul><h3 id="컴포넌트-생명주기-뷰-훅"><a href="#컴포넌트-생명주기-뷰-훅" class="headerlink" title="컴포넌트 생명주기 (뷰 훅)"></a>컴포넌트 생명주기 (뷰 훅)</h3><ul><li>[(ngModel)]=”message”로 바인딩 되어있는 input에 텍스트를 추가하면 this.oldMessage, this.message 를 비교하여 “ngDoCheck()에서 변화감지” 를 출력</li><li>바인딩이없는 input에 입력시 아무런 호출도 일어나지 않습니다.</li><li><strong>View 상태변경</strong> 클릭시 this.shouldShow 상태값 변경되면서 @ViewChild 장식자를 통해 window 지시자에서 가져오는 id값이 달라집니다.</li><li>이전 값과 현재 값이 달라져서 “ngAfterViewChecked()에서 변화감지” 호출</li><li><strong>컴포넌트 삭제</strong> 클릭시 ngOnDestroy() 메서드가 호출됩니다.</li></ul><h2 id="지시자-생명주기"><a href="#지시자-생명주기" class="headerlink" title="지시자 생명주기"></a>지시자 생명주기</h2><p>앞서 살펴본 컴포넌트의 생명주기와 크게 다르지 않습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Directive, Input &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Directive(&#123;</span><br><span class="line">    selector: <span class="string">'[my-click]'</span>,</span><br><span class="line">    host: &#123; <span class="string">'(click)'</span>: <span class="string">'onClick()'</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClickDirective</span></span>&#123;</span><br><span class="line">    _prop: string = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    @Input()</span><br><span class="line">    set prop(name: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>._prop = name || <span class="string">''</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"@Input prop() 세터 메서드 호출"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    onClick() &#123; <span class="built_in">console</span>.log(<span class="string">"지시자 : onClick() 메서드 호출"</span>); &#125;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123; <span class="built_in">console</span>.log(<span class="string">"1-지시자 : constructor()"</span>); &#125;    </span><br><span class="line">    ngOnChanges() &#123; <span class="built_in">console</span>.log(<span class="string">"2--지시자 : ngOnChanges()"</span>); &#125;</span><br><span class="line">    ngOnInit() &#123; <span class="built_in">console</span>.log(<span class="string">"3---지시자 : ngOnInit()"</span>); &#125;</span><br><span class="line">    ngDoCheck() &#123; <span class="built_in">console</span>.log(<span class="string">"4----지시자 : ngDoCheck()"</span>); &#125;    </span><br><span class="line">    ngAfterContentInit() &#123; <span class="built_in">console</span>.log(<span class="string">"5-----지시자 : ngAfterContentInit()"</span>); &#125;</span><br><span class="line">    ngAfterContentChecked() &#123; <span class="built_in">console</span>.log(<span class="string">"6------지시자 : ngAfterContentChecked()"</span>); &#125;</span><br><span class="line">    ngAfterViewInit() &#123; <span class="built_in">console</span>.log(<span class="string">"7-------지시자 : ngAfterViewInit()"</span>); &#125;</span><br><span class="line">    ngAfterViewChecked() &#123; <span class="built_in">console</span>.log(<span class="string">"8--------지시자 : ngAfterViewChecked()"</span>); &#125;</span><br><span class="line">    ngOnDestroy() &#123; <span class="built_in">console</span>.log(<span class="string">"9---------지시자 : ngOnDestroy()"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>지시자 추가</strong> 를 클릭하면 my-click 지시자가 호출됩니다. prop 속성 바인딩을 통해 자신의 상태를 변경하기 때문에 세터 메서드와 ngOnChanges() 훅이 호출되었습니다.</li><li><p>지시자 내부에서 컴포넌트 전용 훅이 호출되지만, 지시자 생명주기로는 사용하지 않습니다. 아래 4가지 공통 훅을 사용합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngOnChanges(...)</span><br><span class="line">ngOnInit(...)</span><br><span class="line">ngDoCheck(...)</span><br><span class="line">ngOnDestroy(...)</span><br></pre></td></tr></table></figure></li><li><p><strong>상태변경</strong> 을 클릭하면 my-click 지시자의 prop 속성값이 변하면서 지시자 내부에서는 상태변경과 검사를 위한 훅 메서드가 호출됩니다.</p></li><li><strong>my-click 지시자</strong> 를 클릭하면 onClick() 메서드가 호출 되면서 상태 점검 ngDoCheck() 이 뒤이어 호출됩니다.</li></ul><h2 id="Angular-vs-React"><a href="#Angular-vs-React" class="headerlink" title="Angular vs. React"></a>Angular vs. React</h2><table><thead><tr><th>Angular</th><th>React</th></tr></thead><tbody><tr><td>constructor</td><td>constructor()</td></tr><tr><td>ngOnChanges</td><td>componentWillMount()</td></tr><tr><td>ngOnInut</td><td>render()</td></tr><tr><td>ngDoCheck</td><td>componentDidMount()</td></tr><tr><td>ngAfterContentInit</td><td>componentWillReceiveProps()</td></tr><tr><td>ngAfterContentChecked</td><td>shouldComponentUpdate()</td></tr><tr><td>ngAfterViewInit</td><td>componentWillUpdate()</td></tr><tr><td>ngAfterViewChecked</td><td>render()</td></tr><tr><td>ngOnDestory</td><td>componentDidUpdate()</td></tr><tr><td></td><td>componentWillUnmount()</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;생명주기-life-cycle&quot;&gt;&lt;a href=&quot;#생명주기-life-cycle&quot; class=&quot;headerlink&quot; title=&quot;생명주기(life cycle)&quot;&gt;&lt;/a&gt;생명주기(life cycle)&lt;/h2&gt;&lt;p&gt;컴포넌트와 지시자는 &lt;stro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>리액트(React) 순수함수 (HOC 개념정리)</title>
    <link href="https://shlee1353.github.io/2019/07/04/higher-order-components/"/>
    <id>https://shlee1353.github.io/2019/07/04/higher-order-components/</id>
    <published>2019-07-04T10:45:02.000Z</published>
    <updated>2019-07-04T10:52:57.270Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/higher-order-components/1.png" alt=""></p><p>Higher-Order Components HOC는 컴포넌트 로직을 재사용하기 위한 리액트의 고급기술입니다. 함수로서 컴포넌트를 인자로 받아 새로운 컴포넌트를 리턴합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>기존 컴포넌트가 props를 받아 UI를 만들었다면, HOC는 컴포넌트를 다른 컴포넌트로 바꿉니다. HOC는 Redux’s connect, Realy’s createFragmentContainer에서 흔히 사용하고 있습니다. 리액트에서 컴포넌트는 코드 재사용을 위한 매우 중요한 유닛입니다.</p><p><a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="external">https://reactjs.org/docs/higher-order-components.html</a></p><p>ComponentList와 BlogPost는 동일하지 않지만, 같은 로직을 가지고 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addChangeListener() -&gt; handleChange() -&gt; removeChangeListener()</span><br></pre></td></tr></table></figure><p>앱 전체적으로 봤을 때 이러한 로직은 자주 사용되는 패턴입니다. 이러한 로직을 하나의 장소에서 관리하고 여러 컴포넌트에서 사용할 수 있도록 추상화작업이 필요합니다. 이럴때 HOC가 필요합니다. DataSource를 구독하고 있는 CommentList, BlogPost 컴포넌트를 제작할 수 있는 함수를 만들어 보도록 하겠습니다. 이 함수는 인자로 데이터를 prop로 받을 수 있는 자식 컴포넌트를 받습니다. 이 함수를 withSubscription 이라고 부르도록 하겠습니다.</p><p><strong>첫번째 파라미터는 wrapped 컴포넌트이며, 두 번째 파라미터로 DataSource와 현재 props값을 받습니다.</strong></p><p>CommentListWithSubscription과 BlogPostWithSubscription이 랜더되면, CommentList와 BlogPost는 data prop로 전달됩니다. 이 값에는 DataSource에서 받은 현재값도 포함됩니다. HOC는 주입된 컴포넌트를 수정하지도 않으며 inheritance를 사용하지도 않습니다. wrapped 컴포넌트는 새로운 props, data는 물론 부모 container의 모든 props를 받습니다. Wrapped component는 어떻게 왜 데이터가 사용되는지, 어디서 오는지 고민할 필요가 없습니다.</p><p>리액트의 HOC의 구조를 보면 고차함수가 생각납니다. 고차함수를 만족시키는 조건으로는, 첫째, 함수를 파라미터로 전달 받는 함수, 둘째, 함수를 리턴하는 함수입니다.</p><h2 id="어디에-쓰이나"><a href="#어디에-쓰이나" class="headerlink" title="어디에 쓰이나?"></a>어디에 쓰이나?</h2><ol><li>비즈니스 로직을 담당하는 컴포넌트와 디스플레이를 담당하는 컴포넌트를 분리하여 사용할때</li><li>로딩 중 화면표시, 유저 인증 로직 처리 (컴포넌트 내에서 권한 체크나 로그인 상태를 체크인 하기 보다는 인증로직을 HOC로 분리)</li></ol><p>아래와 같이 Button, Label 컴포넌트가 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button&gt;button&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line">        &lt;Label&gt;label&lt;<span class="regexp">/Label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> &lt;button&gt;&#123;props.children&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">class Label extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return(</span></span><br><span class="line"><span class="regexp">      &lt;label&gt;&#123;this.props.children&#125;&lt;/</span>label&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render(&lt;App /&gt;, document.getElementById('root'));</span><br></pre></td></tr></table></figure><p>HOC 컴포넌트는 컴포넌트를 인자로 받아서 새로운 컴포넌트를 리턴합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">InnerComponent</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;InnerComponent /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>완성코드</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">InnerComponent</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  update()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;InnerComponent </span><br><span class="line">        &#123;...this.props&#125;</span><br><span class="line">        &#123;...this.state&#125;</span><br><span class="line">        update=&#123;<span class="keyword">this</span>.update.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button&gt;button&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line">        &lt;LabelHOC&gt;label&lt;<span class="regexp">/LabelHOC&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Button = HOC(<span class="function">(<span class="params">props</span>) =&gt;</span> </span><br><span class="line">  &lt;button onClick=&#123;props.update&#125;&gt;&#123;props.children&#125; - &#123;props.count&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">class Label extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return(</span></span><br><span class="line"><span class="regexp">      &lt;label onMouseMove=&#123;this.props.update&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &#123;this.props.children&#125; - &#123;this.props.count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>label&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LabelHOC = HOC(Label)</span><br><span class="line">render(&lt;App /&gt;, document.getElementById('root'));</span><br></pre></td></tr></table></figure><p>실무에서 storybook 컴포넌트를 정리하면서 HOC를 사용했습니다. 예를들어, true, false에 따라 열리고 닫히는 모달팝업이 여러개 있을 경우, 열고/닫기 로직을 HOC로 만들어 놓고 이를 여러개의 모달 컴포넌트에 적용하였습니다. 특별히, storybook 내부에서는 state관리가 직관적으로 되지않기 때문에 이를 해결하는 방법으로 HOC사용 및 플러그인이 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/higher-order-components/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Higher-Order Components HOC는 컴포넌트 로직을 재사용하기 위한 리액트의 고급기술입니다. 함수로서 컴포넌트를 인자
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>리액트(React) 라이프사이클 v16.3 간단정리</title>
    <link href="https://shlee1353.github.io/2019/07/04/react-component-lifecycle/"/>
    <id>https://shlee1353.github.io/2019/07/04/react-component-lifecycle/</id>
    <published>2019-07-04T10:11:50.000Z</published>
    <updated>2019-07-04T10:47:30.185Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/react-component-lifecycle/1.jpg" alt=""></p><h1 id="리액트-라이프-사이클"><a href="#리액트-라이프-사이클" class="headerlink" title="리액트 라이프 사이클"></a>리액트 라이프 사이클</h1><p>리액트버전 16.3에서 새로운 라이프 사이클 2개가 소개되었습니다. getDerivedStateFromProps, getSnapshotBeforeUpdate 이며 기존에 사용하던componentWillMount, componentWillUpdate, componentWillReceiveProps 는 점차 지원이 중단되어 버전 17에서는 완전히 삭제될 예정이라고 합니다.</p><p>컴포넌트 라이프사이클 초기 화면 로딩시:</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><p>첫 화면 랜더링 후 props가 바뀔경우:</p><ul><li>getDerivedStateFromProps</li><li>shouldComponentUpdate (if return false일 경우 종료, true면 랜더진행)</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><p>state가 바뀔 경우에는 바로 shouldComponentUpdate 부터 라이프사이클이 진행 됩니다. 라이프 사이클의 기본적인 사용방법과 각각의 라이프 사이클에 대해 알아 보도록 하겠습니다.</p><h2 id="1-Initializing-state"><a href="#1-Initializing-state" class="headerlink" title="1. Initializing state"></a>1. Initializing state</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    currentColor: <span class="keyword">this</span>.props.defaultColor,</span><br><span class="line">    palette: <span class="string">'rgb'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state값 초기화 시, constructor 또는 state 객체에 바로 추가하면 됩니다.</p><h2 id="2-Fetching-external-data"><a href="#2-Fetching-external-data" class="headerlink" title="2. Fetching external data"></a>2. Fetching external data</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._asyncRequest = asyncLoadData().then(</span><br><span class="line">      externalData =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>._asyncRequest = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;externalData&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>외부 데이터를 추가 시 componentDidMount에 추가합니다.</p><h2 id="3-Adding-event-listeners"><a href="#3-Adding-event-listeners" class="headerlink" title="3. Adding event listeners"></a>3. Adding event listeners</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Event listeners are only safe to add after mount,</span></span><br><span class="line">    <span class="comment">// So they won't leak if mount is interrupted or errors.</span></span><br><span class="line">    <span class="keyword">this</span>.props.dataSource.subscribe(</span><br><span class="line">      <span class="keyword">this</span>.handleSubscriptionChange</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// External values could change between render and mount,</span></span><br><span class="line">    <span class="comment">// In some cases it may be important to handle this case.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>.state.subscribedValue !==</span><br><span class="line">      <span class="keyword">this</span>.props.dataSource.value</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        subscribedValue: <span class="keyword">this</span>.props.dataSource.value,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>이벤트 리스너 또한 componentDidMount에 추가합니다.</p><h2 id="4-Updating-state-based-on-props"><a href="#4-Updating-state-based-on-props" class="headerlink" title="4. Updating state based on props"></a>4. Updating state based on props</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.currentRow !== state.lastRow) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        isScrollingDown: props.currentRow &gt; state.lastRow,</span><br><span class="line">        lastRow: props.currentRow,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>state의 변화가 필요하면, state 객체를 반환합니다. 이는 마치, this.setState({stateName: value})와 같습니다. state 변화가 필요없을 경우는 null을 반환합니다.</p><h2 id="5-Invoking-external-callbacks"><a href="#5-Invoking-external-callbacks" class="headerlink" title="5. Invoking external callbacks"></a>5. Invoking external callbacks</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>.state.someStatefulValue !==</span><br><span class="line">      prevState.someStatefulValue</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.onChange(<span class="keyword">this</span>.state.someStatefulValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>constructor()</strong></p><p>이 메소드는 새로운 객체가 생성될 때 마다 호출됩니다. super(props)은 부모 클래스의 생성자를 호출하며 this.props 로 접근이 가능합니다. 또한, 콜백으로 전달될 함수들을 바인딩 할 때도 사용됩니다. this.setState() 또는 Ajax 요청을 사용하시면 안됩니다. (componentDidMount()에서 사용)</p><p><strong>static getDerivedStateFromProps()</strong></p><p>이 메소드는 컴포넌트 초기화 또는 새로운 props를 받았을 때 일어납니다. 인스턴스가 아닌 클래스로 존재합니다. 그렇기 때문에 this 키워드 접근이 불가능합니다. this.setState() 사용 대신 state를 업데이트 하기 위한 객체를 리턴하며 업데이트가 필요없을 경우 null값을 리턴합니다. 오로지 변화가 생긴 state만 리턴하고 나머지는 유지됩니다. this.setState()는 이 메소드를 호출하지 못합니다.</p><p><strong>houldComponentUpdate()</strong></p><p>새로운 렌더링 과정이 필요 없을 경우 라이프사이클을 빠져나올 수 있습니다. 리엑트는 기본적으로 깊은 비교를 하지 않습니다. 그렇기 때문에 props, state가 업데이트 될 경우 리렌더링이 필요하다고 생각합니다.</p><p><strong>render()</strong></p><p>이 메소드가 호출되면 this.props와 this.state가 분석되며 리액트 엘리먼트를 리턴합니다. render() 메소드는 state를 변경하면 안되며 브라우저와 직접적으로 상호작용하면 안됩니다. 브라우저와 연동하려면 componentDidMount()안에서 하면 됩니다. shouldComponentUpdate()가 false를 리턴할 경우 발생하지 않습니다.</p><p><strong>componentDidMount()</strong></p><p>이 메소드는 전체 라이프사이클에서 한 번만 호출됩니다. 데이터와 관련된 로직을 실행하기에 적합합니다. componentDidupdate()는 prevProps, prevState, snapshot을 파라미터로 가질 수 있습니다. 이 외에도 componentWillUnmount(), componentDidCatch()가 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/react-component-lifecycle/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;리액트-라이프-사이클&quot;&gt;&lt;a href=&quot;#리액트-라이프-사이클&quot; class=&quot;headerlink&quot; title=&quot;리액트 라
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>뷰(Vue) 기본개념 빠르게 알아보자</title>
    <link href="https://shlee1353.github.io/2019/07/04/vue-quick-start/"/>
    <id>https://shlee1353.github.io/2019/07/04/vue-quick-start/</id>
    <published>2019-07-04T10:01:00.000Z</published>
    <updated>2019-07-04T10:02:03.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g vue-cli</span><br><span class="line">vue init simple hellovuejs // 애플리케이션 생성</span><br></pre></td></tr></table></figure><ul><li>애플리케이션을 생성하고 index.html 파일을  아래처럼 수정하도록 하겠습니다.</li><li>리액트나 앵귤러와 달리 초기 환경설정이 매우 간편하다는 장점이 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;<span class="number">02</span><span class="number">-01</span>&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue/dist/vue.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="</span>simple<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var model = &#123;</span></span><br><span class="line"><span class="string">            message : "</span>첫 번째 Vue.js 앱 입니다!<span class="string">"</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var simple = new Vue(&#123;</span></span><br><span class="line"><span class="string">            el : '#simple',</span></span><br><span class="line"><span class="string">            data : model</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Vue.js 는 기본적으로 MVVM 디자인 패턴을 사용하고 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View</span></span><br><span class="line">&lt;div id=<span class="string">"simple"</span>&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><ul><li>View는 화면상에 보여지는 영역이며 중괄호 두개를 사용하여 데이터 값과 연동됩니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View Model</span></span><br><span class="line"><span class="keyword">var</span> simple = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el : <span class="string">'#simple'</span>,</span><br><span class="line">data : model</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model</span></span><br><span class="line"><span class="keyword">var</span> model = &#123;</span><br><span class="line">message : <span class="string">"첫 번째 Vue.js 앱 입니다!"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>모델(Model)을 변경하면 뷰모델(ViewModel) 객체를 통해 HTML DOM이 즉시 변경됩니다.</li><li>index.html 파일을 실행 한 뒤 콘솔 창을 띄웁니다. 그 다음 아래 코드를 넣어주시면, 화면상에서 바로 값이 반영되는 것을 확인 할 수 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.message = <span class="string">"hello Vue.js"</span>;</span><br></pre></td></tr></table></figure><h2 id="기본-디렉티브"><a href="#기본-디렉티브" class="headerlink" title="기본 디렉티브"></a>기본 디렉티브</h2><ul><li>미리 선언해 놓은 디렉티브를 사용하면 좀 더 효율적으로 Vue.js를 사용하실 수 있습니다.</li></ul><p><strong>v-text</strong></p><ul><li>v-text는 이전에 사용한 중괄호 두개와 같은 기능을 하며 자바스크립트의 innerText 속성과 연결됩니다. (사용권장)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"simple"</span>&gt;</span><br><span class="line">    &lt;h2 v-text=<span class="string">"message"</span>&gt;&lt;/h2&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-html <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-02.html" target="_blank" rel="external">예시</a></strong></p><ul><li>v-html은 innerHTML 속성과 연결되며 태그 문자열을 파싱하여 화면에 나타냅니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"simple"</span>&gt;</span><br><span class="line">    &lt;h2 v-html=<span class="string">"message"</span>&gt;&lt;/h2&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-bind <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-03.html" target="_blank" rel="external">예시</a></strong></p><ul><li>v-bind는 요소 객체의 속성들을 단방향 바인딩 하기위해 사용합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"a"</span> type=<span class="string">"text"</span> v-bind:value=<span class="string">"message"</span>&gt;</span><br><span class="line">&lt;img v-bind:src=<span class="string">"imagePath"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> model = &#123;</span><br><span class="line">message : <span class="string">'v-bind 디렉티브'</span>,</span><br><span class="line">imagePath : <span class="string">'http://sample.bmaster.kro.kr/photos/61.jpg'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>v-model <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-04.html" target="_blank" rel="external">예시</a>, <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-05.html" target="_blank" rel="external">예시</a></strong></p><ul><li>앞에서 살펴본 단방향 바인딩은 HTML 요소에서 값을 변경하더라도 모델 객체의 값이 바뀌지 않습니다. </li><li>v-model은 요소에서 변경한 값이 모델 객체에 반영되는 양방향 바인딩을 제공합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"name"</span> placeholder=<span class="string">"이름을 입력하세요"</span> /&gt;</span><br><span class="line">입력된 이름 : &lt;h2 v-html="name"&gt;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> twoway = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el : <span class="string">'#simple'</span>,</span><br><span class="line">    data : &#123;</span><br><span class="line">        name : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>v-model 디렉티브는 텍스트 박스뿐만 아니라 다양한 입력 폼 필드에서도 사용 가능합니다.</li><li>링크 되어 있는 예시코드를 살펴보면 배열 fruits을 가지고 있는 model을 두 개의 Vue 객체(#simple1, #simple2)에서 참조합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"checkbox"</span> value=<span class="string">"1"</span> v-model=<span class="string">"fruits"</span>&gt;사과, </span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> value=<span class="string">"2"</span> v-model=<span class="string">"fruits"</span>&gt;키위, </span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> value=<span class="string">"3"</span> v-model=<span class="string">"fruits"</span>&gt;포도,</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> value=<span class="string">"4"</span> v-model=<span class="string">"fruits"</span>&gt;수박,</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> value=<span class="string">"5"</span> v-model=<span class="string">"fruits"</span>&gt;참외</span><br><span class="line"></span><br><span class="line">선택한 과일들 : &lt;span v-html="fruits"&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> model = &#123;</span><br><span class="line">fruits : []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>v-show <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-06.html" target="_blank" rel="external">예시</a></strong>,<br><strong>v-if <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-07.html" target="_blank" rel="external">예시</a></strong></p><ul><li>v-show, v-if는 Vue 객체의 data 속성 값에 따라 렌더링 여부를 결정하는 기능입니다.</li><li>둘의 차이점은 v-show는 일단 HTML 요소를 렌더링한 후에 display 속성으로 화면단을 제어합니다.</li><li>v-if 디렉티브는 조건에 부합되지 않으면 렌더링을 하지 않습니다.</li><li>자주 화면이 변경되는 부분에 대해서는 v-show 디렉티브를 사용하는 것이 바람직합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-show</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"amount"</span> /&gt;</span><br><span class="line">&lt;img v-show=<span class="string">"amount &lt; 0"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v-if</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"balance"</span> /&gt;</span><br><span class="line">&lt;span v-<span class="keyword">if</span>=<span class="string">"balance &gt;= 1000000"</span>&gt;Gold&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span v-else-if="balance &gt;= 500000"&gt;Silver&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure><p><strong>v-for <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-08.html" target="_blank" rel="external">예시</a>, <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-09.html" target="_blank" rel="external">예시</a></strong></p><ul><li>반복적인 데이터 렌더링을 하기 위해 v-for 디렉티브를 사용합니다.</li><li>예시코드를 확인하면 model에서 contacts 배열을 가져와 화면에 보여주고 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr v-<span class="keyword">for</span>=<span class="string">"(contact, index) in contacts"</span>&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;index+<span class="number">1</span>&#125;&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;td&gt;&#123;&#123;contact.name&#125;&#125;&lt;/</span>td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;contact.tel&#125;&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;td&gt;&#123;&#123;contact.address&#125;&#125;&lt;/</span>td&gt;</span><br><span class="line">&lt;<span class="regexp">/tr&gt;</span></span><br></pre></td></tr></table></figure><ul><li>객체인 경우는 키를 이용해 값에 접근합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;option v-<span class="keyword">for</span>=<span class="string">"(val, key, index) in regions"</span> v-bind:value=<span class="string">"key"</span>&gt;&#123;&#123; index+<span class="number">1</span> &#125;&#125; : &#123;&#123;val&#125;&#125;&lt;<span class="regexp">/option&gt;</span></span><br></pre></td></tr></table></figure><h2 id="기타-디렉티브-및-계산형-속성"><a href="#기타-디렉티브-및-계산형-속성" class="headerlink" title="기타 디렉티브 및 계산형 속성"></a>기타 디렉티브 및 계산형 속성</h2><p><strong>v-pre <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-11.html" target="_blank" rel="external">예시</a></strong>,<br><strong>v-once <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-12.html" target="_blank" rel="external">예시</a></strong></p><ul><li>v-pre 디렉티브는 HTML 요소에 대한 컴파일을 수행하지 않습니다.</li><li>v-once 디렉티브는 HTML 요소를 단 한 번만 렌더링하기 때문에 데이터를 변경하더라도 다시 렌더링되지 않습니다.</li></ul><p><strong>계산형 <a href="https://github.com/stepanowon/vuejs_book/blob/master/ch02/02-13.html" target="_blank" rel="external">예시</a></strong></p><ul><li>연산 로직이 필요할 경우 계산형 속성(Computed Property)를 사용해하여 필요한 함수를 등록할 수 있습니다.</li><li>함수 안에서 this는 Vue 객체 자신을 참조합니다.</li><li>num 값이 문자열로 다루어지기 때문에 Number(), parseInt() 함수를 사용해서 명시적으로 숫자로 변환해주어야 합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed : &#123;</span><br><span class="line">    sum : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="keyword">this</span>.num);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(n) || n &lt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="number">1</span>+n) * n) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Vue.js도 리액트 처럼 렌더링 속도 향상을 위해 가상DOM을 사용합니다. 가상 DOM에 대한 간단한 <a href="https://www.youtube.com/watch?v=BYbgopx44vo" target="_blank" rel="external">영상</a></li></ul><h2 id="Vue-인스턴스"><a href="#Vue-인스턴스" class="headerlink" title="Vue 인스턴스"></a>Vue 인스턴스</h2><p><strong>el, data, computed</strong></p><p>Vue 인스턴스에는 el, data, computed 옵션이 있습니다. 먼저 data 옵션에 주어진 모든 속성들은 Vue 인스턴스 내부에서 직접 이용되지 않고 Vue 인스턴스와 Data 옵션에 주어진 객체 사이에 프록시를 두어 처리합니다. 그래서 값에 접근할 때 vm.name으로 가능합니다. 직접 data에 접근하려면 vm.$data.name 방법이 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = &#123;</span><br><span class="line">name : <span class="string">"Ryan"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el : <span class="string">'#test'</span>,</span><br><span class="line">data : model</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>el 옵션은 Vue 인스턴스에 연결할 HTML DOM요소를 지정하며 여러개 요소에 지정할 수 없습니다. Computed 옵션에 지정한 것은 함수였지만 Vue 인스턴스는 프록시 처리하여 마치 속성처럼 취급합니다.</p><p><strong>메서드</strong></p><p>Vue 인스턴스에서 사용할 메서드를 등록하는 옵션입니다. 직접호출, 디렉티브 포현식, 콧수염 표현식에서도 사용할 수 있습니다. 계산형 속성과 차이가 있다면 결과값의 캐싱 여부입니다. 메서드는 캐싱없이 매번 실행합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;&#123;&#123;sum()&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">.</span></span><br><span class="line"><span class="regexp">.</span></span><br><span class="line"><span class="regexp">methods :  &#123;</span></span><br><span class="line"><span class="regexp">sum : function() &#123;</span></span><br><span class="line"><span class="regexp">var n = Number(this.num);</span></span><br><span class="line"><span class="regexp">if (Number.isNaN(n) || n &lt; 1) return 0;</span></span><br><span class="line"><span class="regexp">return ((1+n)*n)/</span><span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>관찰속성</strong></p><p>관찰속성은 긴 처리 시간이 필요한 비동기 처리에 적합하다는 특징을 가지고 있습니다.</p><h2 id="컴포넌트-심화"><a href="#컴포넌트-심화" class="headerlink" title="컴포넌트 심화"></a>컴포넌트 심화</h2><p><strong>전역 컴포넌트</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="comment">// 등록</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 루트 인스턴스 생성</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span></span><br><span class="line">&#125;)</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">// 랜더링 결과</span></span><br><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p><strong>단일 컴포넌트와 전역 컴포넌트의 차이점</strong></p><ul><li>&#60;template&#62; 에는 id 특서을 부여하지 않음</li><li>&#60;script&#62; 영역에서는 Vue 컴포넌트의 template을 지정하지 않음</li><li>Vue.component()로 이름과 template 속서을 지정하지 않음</li><li>단일 컴포넌트는 name 속성을 지정해 반드시 객체를 export 해야함</li><li>컴포넌트에서 사용할 스타일은 &#60;style&#62; 내부에 작성</li></ul><p><strong>전역 수준 컴포넌트의 문제점</strong></p><ul><li>빌드 단계가 없으므로 최신 자바스크립트 문법을 사용할 수 없습니다.</li><li>CSS 스타일을 빌드하고 모듈화할 수 있는 기능을 제공하지 않습니다.</li><li>컴포넌트 템플릿 작성시 HTML 파일안에 여러개의 &#60;template &#47;&#62; 태그가 작성되어야 하기 때문에 식별이 어렵습니다.</li></ul><p>Vue-CLI가 제공하는 프로젝트 템플릿 중 webpack-simple에 포함되어 있는 vue-loader라는 구성 요소가  단일 파일 컴포넌트를 지원합니다. 확장자가 .vue인 파일에  &#60;template &#47;&#62;,  &#60;script &#47;&#62;,  &#60;style &#47;&#62; 을 작성하면 vue-loader는 이 파일을 파싱하고 다른 로더들을 활용해 하나의 모듈로 조합합니다. 특히, css-loader를 이용해 CSS 스타일을 전처리할 수 있으며, 스타일 정보를 모듈화할 수도 있습니다.</p><p>App.vue 파일을 열어보면 &#60;template &#47;&#62;,  &#60;script &#47;&#62;,  &#60;style &#47;&#62; 3개의 기본 영역을 확인할 수 있습니다. App.vue 컴포넌트를 화면에 담기 위해 main.js를 사용합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./components/TodoList.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(TodoList)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>App.vue를 비롯한 .js 파일들은 트랜스파일되고, 번들링되어 ./dist/build.js 파일을 생성하여 최종적으로 index.html 파일에 보여집니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"ko"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;todolistapp&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">"/dist/build.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>본격적으로, 예제로 살펴볼 todolistapp 디렉토리와 파일구조는 다음과 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">ㄴcomponents</span><br><span class="line"> ㄴEventBus.vue</span><br><span class="line"> ㄴInputTodo.vue</span><br><span class="line"> ㄴList.vue</span><br><span class="line"> ㄴTodoList.vue</span><br><span class="line">ㄴmain.js</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><p>1.EventBus.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">var</span> eventBus = <span class="keyword">new</span> Vue(); <span class="comment">// 이벤트버스 생성</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>2.InputTodo.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;...&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input class="input" type="text" id="task" v-model.trim="todo" </span></span><br><span class="line"><span class="regexp">        placeholder="입력 후 엔터!" v-on:keyup.enter="addTodo"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span class="addbutton" v-on:click="addTodo"&gt;추 가&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;    </span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'./EventBus.vue'</span> <span class="comment">// Import 이벤트 버스</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name : <span class="string">'input-todo'</span>,</span><br><span class="line">    data : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">todo</span> : <span class="string">""</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods : &#123;</span><br><span class="line">        addTodo : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            eventBus.$emit(<span class="string">'add-todo'</span>, <span class="keyword">this</span>.todo); <span class="comment">// 이벤트 발행</span></span><br><span class="line">            <span class="keyword">this</span>.todo = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>input을 통하여 자동으로 trim 된 값이(v-model.trim=”todo”) data로 전달됩니다.</li><li>엔터 또는 버튼을 누르면 addTodo가 실행되고, this.todo의 값을 포함한 ‘add-todo’ 이벤트를 등록합니다.</li></ul><p>3.List.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;...&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul id="todolist"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li v-for="(a, index) in todolist" v-bind:class="checked(a.done)"</span></span><br><span class="line"><span class="regexp">            v-on:click="doneToggle(index)"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span&gt;&#123;&#123; a.todo &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;span v-<span class="keyword">if</span>=<span class="string">"a.done"</span>&gt; (완료)&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span class="close" v-on:click.stop="deleteTodo(index)"&gt;&amp;#x00D7;&lt;/</span>span&gt;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">import eventBus from './EventBus.vue'</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">    created : function() &#123;</span></span><br><span class="line"><span class="string">         eventBus.$on('add-todo', this.addTodo); // 이벤트 구독</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    data : function() &#123;</span></span><br><span class="line"><span class="string">        return &#123;</span></span><br><span class="line"><span class="string">            todolist : [</span></span><br><span class="line"><span class="string">                &#123; todo : "</span>영화보기<span class="string">", done:false &#125;,</span></span><br><span class="line"><span class="string">                &#123; todo : "</span>주말 산책<span class="string">", done:true &#125;,</span></span><br><span class="line"><span class="string">                &#123; todo : "</span>ES6 학습<span class="string">", done:false &#125;,</span></span><br><span class="line"><span class="string">                &#123; todo : "</span>잠실 야구장<span class="string">", done:false &#125;,</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    methods : &#123;</span></span><br><span class="line"><span class="string">        checked : function(done) &#123;</span></span><br><span class="line"><span class="string">            if(done) return &#123; checked:true &#125;;</span></span><br><span class="line"><span class="string">            else return &#123; checked:false &#125;;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        addTodo : function(todo) &#123;</span></span><br><span class="line"><span class="string">            if (todo !== "</span><span class="string">") &#123;</span></span><br><span class="line"><span class="string">                this.todolist.push(&#123; todo : todo, done:false &#125;);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        doneToggle : function(index) &#123;</span></span><br><span class="line"><span class="string">            this.todolist[index].done = !this.todolist[index].done;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        deleteTodo : function(index) &#123;</span></span><br><span class="line"><span class="string">            this.todolist.splice(index,1);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>eventBus.$on을 통하여 ‘add-todo’ 이벤트를 받아 this.addTodo를 실행합니다.</li><li>전달된 todo값의 유무를 확인 후 true이면 todolist 배열에 넘어온 값을 추가 합니다.</li><li>EventBus.$off()를 사용하면 이벤트를 제거할 수 있습니다.</li></ul><p>4.TodoList.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;...&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="todolistapp"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div id="header" class="header"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h2&gt;Todo List App&lt;/</span>h2&gt;</span><br><span class="line">            &lt;input-todo /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;list&gt;&lt;/</span>list&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> InputTodo <span class="keyword">from</span> <span class="string">'./InputTodo.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List.vue'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name : <span class="string">'todo-list'</span>,</span><br><span class="line">    components : &#123; InputTodo, List &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong>스타일 적용</strong></p><p>기존에는 스타일 태그를 이용한 전역 스타일을 적용하였습니다. 만약, 다른 컴포넌트에서도 동일한 CSS 클래스명을 사용한다면 충돌이 발생합니다. 특정 컴포넌트의 스타일을 지정하려면 범위CSS와 모듈CSS 두 가지 방법이 있습니다.</p><p>1.범위CSS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">ㄴcomponents</span><br><span class="line"> ㄴChild1.vue</span><br><span class="line"> ㄴChild11.vue</span><br><span class="line"> ㄴChild2.vue</span><br><span class="line">ㄴmain.js</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><p>Child1.vue, Child2.vue에는 모두 main 클래스의 스타일이 적용되어 있습니다. 이럴경우, 두 스타일이 충돌되면서 마지막에 선언된 스타일이 적용됩니다. 이때, 스타일 태그에 scoped를 추가하면 이를 해결할 수 있습니다. 범위 CSS를 적용하면 data-v-xxxxx 형태의 속성이 부여됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.main&#123;border:1px solid #000;background-color:aqua&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>주의점</p><ul><li>특성 선택자(attribute selector)를 사용하기 때문에 브라우저에서 스타일 적용 속도가 느립니다. 그렇기 대문에 속도가 빠른 ID, 클래스, 태그명 선택자로 요소를 선택해 스타일을 적용해야 합니다.</li><li>부모 컴포넌트에 적용된 범위CSS는 하위 컴포넌트에도 반영이 됩니다.</li></ul><p>2.CSS모듈</p><p>CSS모듈은 CSS를 객체처럼 다루는 것을 의미합니다. 설정하는 방법은 간단합니다. 스타일 태그에 module을 추가하면 CSS 모듈 모드가 작동되면서 그 결과로 생성된 클래스 식별 객체는 $style이름으로 컴포넌트의 계산형 속성으로 추가됩니다. 이 스타일은 Vue 인스턴스 내에서 $style 이라는 계산형 속성을 통해서 이용할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button :<span class="class"><span class="keyword">class</span></span>=<span class="string">"$style.hand"</span>&gt; CSS Module을 적용한 버튼&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">.</span></span><br><span class="line"><span class="regexp">.</span></span><br><span class="line"><span class="regexp">&lt;style module&gt;</span></span><br><span class="line"><span class="regexp">.hand&#123;cursor:pointer;background-color:purple;color:yellow&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>적용해야 할 클래스가 여러개일 경우 배열 문법을 이용하며, 자바스크립트에서 접근이 가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class"[$style.box, $style.border]"&gt;Hello World&lt;/div&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">created() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$style);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>슬롯</strong></p><ul><li>기본사용법</li></ul><p>슬롯을 이용해 부모 컴포넌트에서 자식 컴포넌트로 HTML 마크업을 전달 할 수 있습니다. 슬롯을 사용하기 위해서 자식 컴포넌트에서는 &#60;slot&#62;&#60;&#47;slot&#62; 태그를 작성하고 부모 컴포넌트에서는 콘텐츠 영역에서 자식 컴포넌트의 &#60;slot&#62;&#60;&#47;slot&#62; 영역에 나타낼 HTML 마크업을 작성하면 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;I<span class="string">'m the child component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;!-- Content from the parent gets rendered here. --&gt;</span></span><br><span class="line"><span class="string">    &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParentComponent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-component&gt;</span><br><span class="line">      &lt;p&gt;I<span class="string">'m injected content from the parent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;I can still bind to data in the parent'</span>s scope, like <span class="keyword">this</span>! &#123;&#123;myVariable&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>child-component&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> ChildComponent <span class="keyword">from</span> <span class="string">'./ChildComponent.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      myVariable: <span class="string">`I'm just a lonely old variable.`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>자식 컴포넌트에 &#60;slot&#62;&#60;&#47;slot&#62;이 없을경우 부모로부터 전달되는 콘텐츠는 없어집니다. 반대로, 부모에서 어떠한 콘텐츠도 전달하지 않을경우, &#60;slot&#62;&#60;&#47;slot&#62;에 엘리먼트를 추가하면 기본적으로 랜더링 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot&gt;</span><br><span class="line">&lt;p&gt;Hello <span class="keyword">from</span> the child!&lt;/p&gt;</span><br><span class="line">&lt;<span class="regexp">/slot&gt;</span></span><br></pre></td></tr></table></figure><ul><li>명명된 슬롯</li></ul><p>여러 개의 슬롯을 작성할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BurgerComponent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"burger-component"</span>&gt;</span><br><span class="line">    &lt;!-- Elements injected <span class="keyword">with</span> the <span class="string">`slot="top-bun"`</span></span><br><span class="line">    attribute will end up <span class="keyword">in</span> here. --&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"top-bun"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- A slot tag without a name is a catch-all,</span></span><br><span class="line"><span class="regexp">    it will contain any content that doesn't have</span></span><br><span class="line"><span class="regexp">    a `slot=""` attribute. --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;slot&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>slot&gt;</span><br><span class="line">    &lt;!-- Elements injected <span class="keyword">with</span> the <span class="string">`slot="top-bun"`</span></span><br><span class="line">    attribute will end up <span class="keyword">in</span> here. --&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"bottom-bun"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SecretRecipeBurger.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- TOP SECRET, FOR EMPLOYEE EYES ONLY --&gt;</span><br><span class="line">  &lt;burger-component&gt;</span><br><span class="line">    &lt;burger-bun slot=<span class="string">"top-bun"</span>&gt;</span><br><span class="line">      &lt;sesame-seeds&gt;&lt;/sesame-seeds&gt;</span><br><span class="line">      &lt;mayonaise&gt;&lt;/mayonaise&gt;</span><br><span class="line">    &lt;/burger-bun&gt;</span><br><span class="line">    &lt;burger-bun slot="bottom-bun" :toasted="true"&gt;</span><br><span class="line">      &lt;secret-sauce&gt;&lt;/secret-sauce&gt; &lt;!-- I bought it from some hooded</span><br><span class="line">        guy off the street. --&gt;</span><br><span class="line">    &lt;/burger-bun&gt;</span><br><span class="line">    &lt;!-- Everything else gets injected into the middle slot (as it's not named.) --&gt;</span><br><span class="line">    &lt;pickles&gt;&lt;/pickles&gt;</span><br><span class="line">    &lt;lettuce&gt;&lt;/lettuce&gt;</span><br><span class="line">    &lt;bacon&gt;&lt;/bacon&gt;</span><br><span class="line">    &lt;beef-patty&gt;&lt;/beef-patty&gt;</span><br><span class="line">    &lt;cheese-slice&gt;&lt;/cheese-slice&gt;</span><br><span class="line">  &lt;/burger-component&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><strong>참고</strong></p><ul><li><a href="https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c" target="_blank" rel="external">https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c</a></li><li><a href="https://github.com/vuejs/vue-loader/blob/master/docs/en/features/css-modules.md" target="_blank" rel="external">https://github.com/vuejs/vue-loader/blob/master/docs/en/features/css-modules.md</a></li><li><a href="https://css-tricks.com/intro-to-vue-2-components-props-slots/" target="_blank" rel="external">https://css-tricks.com/intro-to-vue-2-components-props-slots/</a></li><li><a href="https://alligator.io/vuejs/component-slots/" target="_blank" rel="external">https://alligator.io/vuejs/component-slots/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;설치&quot;&gt;&lt;a href=&quot;#설치&quot; class=&quot;headerlink&quot; title=&quot;설치&quot;&gt;&lt;/a&gt;설치&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>자바스크립트(JavaScript) this 바인딩 기본개념</title>
    <link href="https://shlee1353.github.io/2019/07/04/js-this-bind/"/>
    <id>https://shlee1353.github.io/2019/07/04/js-this-bind/</id>
    <published>2019-07-04T07:54:24.000Z</published>
    <updated>2019-07-04T08:04:48.754Z</updated>
    
    <content type="html"><![CDATA[<p>자바스크립트에서 this 키워드는 좀 특별합니다. ES5에서는 bind 메소드를 사용해서 this 키워드를 설정 할 수 있으며, ES2015에서는 arrow functions 을 사용해서 고유의 this 키워드를바인딩 할 수 있습니다. (렉시컬 컨텍스트 안에 this를 유지)</p><h2 id="Global-context"><a href="#Global-context" class="headerlink" title="Global context"></a>Global context</h2><p>함수 밖, 글로벌 실행 컨텍스트에서 this는 글로벌 객체를 가르킵니다(strict mode or not)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">a = <span class="number">37</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">this</span>.b = <span class="string">"MDN"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// "MDN" </span></span><br><span class="line"><span class="built_in">console</span>.log(b)         <span class="comment">// "MDN"</span></span><br></pre></td></tr></table></figure><h2 id="Function-context"><a href="#Function-context" class="headerlink" title="Function context"></a>Function context</h2><p>함수 내부에서 this는 함수 호출에 따라 달라집니다. 일반모드에서 함수 내부의 this는 글로벌을 가르키지만, strict mode에서는 undefined이 출력됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-strict mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In a browser:</span></span><br><span class="line">f1() === <span class="built_in">window</span>; <span class="comment">// true </span></span><br><span class="line"><span class="comment">// In Node:</span></span><br><span class="line">f1() === global; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// strict mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>; <span class="comment">// see strict mode</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>call, apply 메소드를 사용해서 this 값을 다른 컨텍스트로 전달 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Custom'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'Global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsThis</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line">whatsThis();          <span class="comment">// 'Global'</span></span><br><span class="line">whatsThis.call(obj);  <span class="comment">// 'Custom'</span></span><br><span class="line">whatsThis.apply(obj); <span class="comment">// 'Custom'</span></span><br></pre></td></tr></table></figure><p>call과 apply의 차이점은 두 번째 파라미터에 배열값을 전달 할 수 있는가 없는가 입니다. 첫 번째로 전달되는 this는 객체로, 숫자나 문자열이 전달 되어도 ToObject로 인해 객체로 변환됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 16</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure><p>f.bind(someObject)은 f와 같은 바디와 스코프를 가진 새로운 함수를 생성합니다. 하지만. this는 본래 함수에서 발생합니다. bind는 중복 설정되지 않고 한 번만 가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>: <span class="string">'azerty'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>: <span class="string">'yoo'</span>&#125;); <span class="comment">// bind only works once!</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">37</span>, <span class="attr">f</span>: f, <span class="attr">g</span>: g, <span class="attr">h</span>: h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g(), o.h()); <span class="comment">// 37, azerty, azerty</span></span><br></pre></td></tr></table></figure><p>arrow 함수에서 this 는 렉시컬 컨텍스트와 연결됩니다. 글로벌 코드에서는 글로벌 객체와 연결됩니다. obj.bar 의 익명함수1 안에 arrow 함수로 선언된 익명함수2의 this는 익명함수1의 this와 연결되어 있고, 이 this는 다시 obj 객체와 연결되어 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예시 1</span></span><br><span class="line"><span class="keyword">var</span> globalObject = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === globalObject); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 예시 2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn = obj.bar();</span><br><span class="line"><span class="built_in">console</span>.log(fn() === obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>함수가 객체의 메소드로 호출되면, 이것의 this는 메소드를 호출한 객체와 연결됩니다. o.f()가 호출되면, 함수 내부의 this는 o 객체가 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  prop: <span class="number">37</span>,</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></span><br></pre></td></tr></table></figure><p>프로토타입 체인에서도 this는 함수가 호출된 객체에 지정이 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b; &#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>수정된 프로그램의 영향이 전체 소스에 퍼지지 않도록 getter, setter 사용합니다. 예를들어</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//기존방법</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 개선방법</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'num'</span>, &#123;<span class="attr">value</span>:<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure><p>defineProperty 함수에서 가장 중요한 것은 세번째 옵션으로 들어가는 인자입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">value : 속성값</span><br><span class="line">writable : 속성값 변경 여부</span><br><span class="line">configurabl e: 속성의 옵션값 변경 여부</span><br><span class="line">enumerable : <span class="keyword">for</span> <span class="keyword">in</span> 반복만 사용 가능 여부</span><br><span class="line">get : value, writable 과 함꼐 사용 못함</span><br><span class="line">set : value, writable 과 함꼐 사용 못함</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 원 = &#123;&#125;;</span><br><span class="line">원._반지름 = <span class="number">0</span>;   <span class="comment">// 겟터 셋터 대상 및 초기값 지정</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( 원, <span class="string">'반지름'</span>, &#123; </span><br><span class="line"> get : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)   </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._반지름; &#125;,</span><br><span class="line"> set : <span class="function"><span class="keyword">function</span>(<span class="params">값</span>) </span>&#123; <span class="keyword">this</span>._반지름 = 값;    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 사용예 </span></span><br><span class="line">원.반지름 = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'원.반지름 = '</span>, 원.반지름);</span><br></pre></td></tr></table></figure><p>defineProperty없이 getter, setter 함수에 대해 알아보도록 하겠습니다. 아래처럼 person 객체에 get, set 함수를 정의해서 사용가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    firstName: <span class="string">'Jimmy'</span>,</span><br><span class="line">    lastName: <span class="string">'Smith'</span>,</span><br><span class="line">    get fullName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    set fullName (name) &#123;</span><br><span class="line">        <span class="keyword">var</span> words = name.toString().split(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.fullName = <span class="string">'Jack Franklin'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.firstName); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(person.lastName) <span class="comment">// Franklin</span></span><br></pre></td></tr></table></figure><p>defineProperty에 의해 생성된 sum은 호출시 this가 o 객체를 향하고 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + <span class="keyword">this</span>.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">  get average() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.a + <span class="keyword">this</span>.b + <span class="keyword">this</span>.c) / <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'sum'</span>, &#123;</span><br><span class="line">    get: sum, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.average, o.sum); <span class="comment">// 2, 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자바스크립트에서 this 키워드는 좀 특별합니다. ES5에서는 bind 메소드를 사용해서 this 키워드를 설정 할 수 있으며, ES2015에서는 arrow functions 을 사용해서 고유의 this 키워드를바인딩 할 수 있습니다. (렉시컬 
      
    
    </summary>
    
    
  </entry>
  
</feed>
