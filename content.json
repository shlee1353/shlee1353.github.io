{"meta":{"title":"Ryan Lee","subtitle":null,"description":null,"author":"Ryan Lee","url":"https://shlee1353.github.io"},"pages":[],"posts":[{"title":"[JS] Inheritance in JavaScript","slug":"JS-Inheritance-in-JavaScript","date":"2017-11-15T01:43:45.000Z","updated":"2017-11-15T01:46:31.000Z","comments":true,"path":"2017/11/15/JS-Inheritance-in-JavaScript/","link":"","permalink":"https://shlee1353.github.io/2017/11/15/JS-Inheritance-in-JavaScript/","excerpt":"","text":"프로토타입(prototype)자바스크립트에는 클래스라는 개념대신 기존의 객체를 복사하여 새로운 객체를 생성하는 프로토타입 언어입니다. 프로토타입은 크게 두 가지로 나뉘어 집니다. 프로토타입 객체를 참조하는 prototype 속성(Prototype Object) 과 객체 멤버인 proto 속성이 참조하는 숨은 링크(Prototype Link) 입니다. 다시말해, proto (숨은링크)는 상위에서 물려받은 객체의 프로토타입에 대한 정보이며 prototype 프로퍼티는 자신을 원형으로 만들어질 새로운 객체들 즉 하위로 물려줄 연결에 대한 속성입니다. 자바스크립트에서 함수가 정의될 때 2가지가 일어납니다. 1. 해당함수에 constructor(생성자) 자격부여. 2. 해당 함수의 prototype object 생성 및 연결. 함수를 생성하면 함수 뿐만 아니라 생성된 함수와 연결되는 Prototype Object도 함께 생겨납니다. 이 객체에 접근하려면 prototype 이라는 속성을 통해 가능합니다. 기본속성으로 constructor와 proto 를 가지고 있습니다. proto 속성은 함수뿐만 아니라 모든 객체가 가지고 있습니다. 객체 생성시 조상이었던 함수의 Prototype Object를 가리킵니다. Prototype Object함수를 정의하면 다른 곳에 생성되는 프로토타입 객체는 자신이 다른 객체의 원형이 되는 객체입니다. 모든 객체는 프로토타입 객체에 접근할 수 있습니다. Prototype Object 는 자기 자신의 분신이며 자신을 원형으로 만들어질 다른 객체가 참조할 프로토타입이 됩니다.1234567891011function Person()&#123;&#125;var joon = new Person(); var jisoo = new Person();Person.prototype.getType = function ()&#123; return \"인간\"; &#125;;console.log(joon.getType()); // 인간 console.log(jisoo.getType()); // 인간 Prototype Link자바스크립트에서 기본 데이터 타입을 제외한 모든 것이 객체입니다. 객체가 만들어지기 위해서는 자신을 만드는 데 사용된 원형인 프로토타입 객체를 이용하여 객체를 만듭니다. 이때 만들어진 객체 안에 proto (비표준) 속성이 자신을 만들어낸 원형을 의미하는 프로토타입 객체를 참조하는 숨겨진 링크가 있습니다. 이 숨겨진 링크를 프로토타입이라고 정의합니다.123function A() &#123;&#125;;var A = new A();console.log(A); 콘솔을 확인해 보면, proto 와 constructor 를 주의 깊게 봐야합니다. 해당 객체의 프로토타입은 A라는 함수 객체이며 이 객체의 생성자 역시 function A() 함수이다. 즉, new 를 사용해 만들어진 객체는 function A()를 자신의 프로토타입으로 사용해서 만들어졌습니다. 상속(Inheritance)123456789101112131415function Person() &#123; this.name = \"annonymous\"; this.sayHello = function() &#123; alert(\"Hello, my name is\" + this.name); &#125;&#125;function Yoda() &#123; var obj = new Person(); obj.name = \"Yoda\"; return obj;&#125;var me = new Yoda();me.sayHello();console.log(me instanceof Yoda); // falseconsole.log(me instanceof Person); // true 초창기 자바스크립트 상속 개념은 2개의 객체가 있을 경우, 하나의 객체에서 다른 객체의 함수 사용을 목적으로한 제한적 상속방법 이였습니다. 예제 코드와 같이 new를 사용해서 obj를 만들고 리턴하는 방법입니다. 하지만, 내부를 살펴보면 me의 인스턴스는 Yoda가 아닌 Person으로 나옵니다. 1234567891011121314var person = &#123; name: \"annoymous\", sayHello: function() &#123; alert(\"Hello, my name is\" + this.name); &#125;&#125;;function Yoda() &#123; this.name = \"Yoda\";&#125;Yoda.prototype = person;var yoda = new Yoda();yoda.sayHello();person.sayHello();console.log(yoda instanceof Yoda); // true 이러한 문제 때문에 function에서 기본적으로 제공하는 prototype을 이용한 방법이 등장 하였습니다. person을 리터럴 방식으로 생성한 뒤 객체형태로 프로퍼티와 메소드를 입력합니다. 이렇게 하면 yoda는 Yoda의 인스턴스로 true값을 반환합니다. 하지만, person이 함수형태가 아니기 때문에, instanceof Person를 이용한 부모객체 확인이 불가능합니다. 자바스크립트에서 함수가 중요한 이유는 프로토타입 속성을 제공하는 유일한 객체이기 때문입니다. 이해를 돕기위해, 앞으로 계속 등장하는 prototype과 constructor에 대해 간단히 알아 보도록 하겠습니다. http://www.nextree.co.kr/p7323/ 123456789101112131415function Car () &#123;&#125;;Car.prototype; // ObjectCar.prototype = &#123; constructor : function() &#123;&#125;, __proto__ : Object&#125;;var audi = new Car();audi = &#123; __proto__ : &#123; constructor : function f () &#123;&#125;, __proto__ : Object &#125;&#125;; Car라는 함수(객체)를 생성한 뒤, 내부를 살펴보면, constructor와_proto_가 있습니다. constructor는 car 함수가 생성될 때 사용된 함수객체를 나타내며, _proto_는 현재 프로토타입에 연결된 부모 객체입니다. 여기에 new를 사용하면, 함수의 prototype을 근간으로하는 신규 객체가 반환됩니다. 자바스크립트의 생성자함수에 대해 좀 더 알아보도록 하겠습니다. 객체(Object)는 Object Literal Notation을 사용해서 생성할 수도 있을 뿐 아니라, Constructor 라는 함수를 이용해서도 생성이 가능합니다. 일반적으로 new Object() 또는 Object Literal Notation을 이용해 생성한 객체들은 모두 자바스크립트 내장 함수인 Object() 라는 객체 생성자(Constructor)함수를 이용해 생성되는 것입니다. 123456789101112131415161718192021222324252627282930313233343536var person1 = &#123; firstName: \"Jason\", lastName: \"Bourne\", age: 25 &#125;;var person2 = new Object();console.log(person1.constructor); //function Object() console.log(person2.constructor); //function Object() console.log(person1.constructor == person2.constructor); //truevar array = [];var number = new Number(3);var bool = new Boolean(true);var str = new String(\"String\");console.log(array.constructor); //function Array()console.log(number.constructor); //function Number()console.log(bool.constructor); //function Boolean()console.log(str.constructor); //function String()function Person(firstName, lastName, age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.getInfo = function() &#123; return \"Name : \" + firstName + \" \" + lastName + \"\\nAge : \" + age; &#125;&#125;var person1 = new Person(\"Jason\", \"Bourne\", 33);var person2 = new Person(\"Jenny\", \"Laurence\", 18);console.log(person1.constructor); //function Personconsole.log(person2.constructor); //function Person 1234567891011121314function Person() &#123; this.name = \"annoymous\"; this.sayHello = function() &#123; alert(\"Hello, my name is\" + this.name); &#125;&#125; function Yoda() &#123; this.name = \"Yoda\";&#125;Yoda.prototype = new Person();var yoda = new Yoda();yoda.sayHello();console.log(yoda instanceof Yoda); // trueconsole.log(yoda instanceof Person); // true 다시 상속으로 돌아와서, prototype을 new로 생성하여 Yoda.prototype으로 지정하는 방법이 있습니다. 이럴경우, yoda는 Yoda와 Person의 인스턴스로 확인이 가능합니다. 하지만, 여기에도 문제가 있습니다. 실제 생성자는 Yoda임에도 불구하고 내부 constructor은 일치하지 않습니다. 그럼에도 불구하고, instanceof를 확인해보면 둘다 true가 나오는데 이러한 이유는 instanceof는 prototype을 기반으로 작동하기 때문입니다. 12345Object.create = function(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; Constructor를 제대로 연결하기 위해 Object.create()가 표준으로 등장하였으며, IE9 이상부터 사용이 가능합니다. 이 함수는 prototype을 인자로 받아 기본함수 F의 prototype()으로 설정을 한 뒤 new 명령어를 통해 새로운 객체를 리턴합니다. 1234567891011121314function Person() &#123; this.name = \"annoymous\"; this.sayHello = function() &#123; alert(\"Hello, my name is\" + this.name); &#125;&#125; function Yoda() &#123; Person.call(this); this.name = \"Yoda\";&#125;Yoda.prototype = Object.create(Person.prototype);Yoda.prototype.constructor = Yoda;var yoda = new Yoda();yoda.sayHello(); 우선 Object.create()를 사용하여 Person.prototype을 상속받습니다. 다음으로, constructor를 Yoda 로 재선언 해준 뒤, call()를 사용하여 조상 메소드에 접근이 가능합니다. 결국, 자바스크립트는 상속은 생성자와 프로토타입에 기반을 두고 있습니다. ES6 에서는 클래스를 사용하여 이를 간단히 표현할 수 있습니다. 123456789class Person &#123; constructor (name, age) &#123; this.name = name; this.age = age &#125; printProfile() &#123; console.log(this.name + this.age); &#125;&#125; ES6 문법으로 작성한 위 내용은 결국 아래와 같습니다. 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.printProfile = function() &#123; console.log(this.name + this.age);&#125; ES6에서 클래스 상속 구현은 extends 절과 super 키워드를 사용하여 구현합니다. extends 절은 클래스가 다른 생성자의 정적/비정적 프로퍼티를 상속 가능하게 합니다. super 키워드는 클래스 constructor 메소드에서 부모 생성자를 호출하거나, 클래스 메소드 내부에서 부모 생성자의 정적/비정적 메소드를 참조할 때 사용합니다. 1234567891011121314151617181920212223class Vehicle &#123;constructor (name, type) &#123; this.name = name; this.type = type; &#125; getName () &#123; return this.name; &#125; getType () &#123; return this.type; &#125;&#125;class Car extends Vehicle &#123; constructor (name) &#123; super(name, 'car'); &#125; getName () &#123; return 'It is a car: ' + super.getName(); &#125;&#125;let car = new Car('Tesla');console.log(car.getName()); // It is a car: Teslaconsole.log(car.getType()); // car 상속의 예시를 살펴보면, Vehicle 의 프로퍼티값으로 name과 type이 있으며, getName(), getType() 두 메소드를 가지고 있습니다. Car는 extends와 super()를 사용하여 Vehicle를 상속받아 car라는 인스턴스를 생성하였습니다. 이 과정에서 getName()은 Car 내부에서 다시 정의가 되었습니다. 마지막에 생성된 car는 Vehicle과 Car의 메소드에 접근할 수 있습니다. 자바스크립트 상속과정을 설명하면서 this가 많이 나왔는데요, 이것도 간단히 정리해보도록 하겠습니다.1234function sayHello () &#123; var greeting = 'hello'; &#125; alert(greeting); // undefined 자바스크립트에서 함수는 위와같이 유호범위(scope)를 생성합니다. 현재 코드에서는, 외부에서 접근이 불가능합니다. 컨텍스트(context)는 내부에서 코드가 돌아가는 객체를 의미합니다. 이때, this를 사용해서 컨텍스트를 참조할 수 있습니다.12345678910111213141516171819202122// function 내부 컨텍스트function f () &#123; console.log(this); &#125;; f(); // window(전역객체)를 가리킴// 메소드 내부 컨텍스트var oj = &#123; method : function () &#123; console.log(this); &#125;&#125;;oj.method(); // 메소드를 담은 객체를 가리킴// 메소드 내부에 중첩된 함수의 컨텍스트var oj = &#123; method : function () &#123; function inner () &#123; console.log(this); // window(전역객체)를 가리킴 &#125;&#125;; 참고 https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67 http://insanehong.kr/post/javascript-prototype/","categories":[],"tags":[]},{"title":"[React] Redux Core Concept","slug":"React-Redux-Core-Concept","date":"2017-11-15T01:38:31.000Z","updated":"2017-11-15T01:40:09.000Z","comments":true,"path":"2017/11/15/React-Redux-Core-Concept/","link":"","permalink":"https://shlee1353.github.io/2017/11/15/React-Redux-Core-Concept/","excerpt":"","text":"Redux?Redux is a state management library that lets you connect directly to application state from anywhere in your app. It also allows you manipulate application state from anywhere in your app. But, to work its magic, Redux requires that your app have a single data store. 리덕스는 자바스크립트 앱의 상태를 포함하고 있는 컨테이너입니다. Redux store라고 부릅니다. 애플리케이션의 모든 상태를 불변의 객체 트리에 저장합니다. 리덕스는 createStore(reducer, [initialState], [enhancer]) 명령어를 통해 생성할 수 있습니다. 사실, 리덕스는 React뿐만 아니라, Angular, Ember, Vue.js 에도 사용이 가능합니다. Redux를 React와 사용할 때 가장 쉬운 방법은 React Redux 바인딩 라이브러리를 사용하는 것입니다. 이 라이브러리를 사용하면 리덕스 상태와 액션을 props와 쉽게 연결 할 수 있습니다. Why do we need Redux?You can’t pass a property directly to the component or components that you wish to target. The reason has to do with how React works. React enforces a chain of command where properties have to flow down from a parent component to an immediate child component. (Link)12345678910111213141516171819202122232425262728293031323334353637383940var Display = React.createClass(&#123; render: function() &#123; return( &lt;div&gt; &lt;p&gt;&#123;this.props.color&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.num&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.size&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;); var Label = React.createClass(&#123; render: function() &#123; return ( &lt;Display color=&#123;this.props.color&#125; num=&#123;this.props.num&#125; size=&#123;this.props.size&#125;/&gt; ); &#125;&#125;); var Shirt = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;Label color=&#123;this.props.color&#125; num=&#123;this.props.num&#125; size=&#123;this.props.size&#125;/&gt; &lt;/div&gt; ); &#125;&#125;); ReactDOM.render( &lt;div&gt; &lt;Shirt color=&quot;steelblue&quot; num=&quot;3.14&quot; size=&quot;medium&quot;/&gt; &lt;/div&gt;, document.querySelector(&quot;#container&quot;)); Spread Operator1234567891011var items = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; function printStuff(a, b, c) &#123; console.log(&quot;Printing: &quot; + a + &quot; &quot; + b + &quot; &quot; + c);&#125; // using the spread operatorprintStuff(...items); // without using the spread operatorprintStuff(items[0], items[1], items[2]); 123456789101112131415161718192021222324252627282930313233343536var Display = React.createClass(&#123; render: function() &#123; return( &lt;div&gt; &lt;p&gt;&#123;this.props.color&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.num&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.size&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;); var Label = React.createClass(&#123; render: function() &#123; return ( &lt;Display &#123;...this.props&#125;/&gt; ); &#125;&#125;); var Shirt = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;Label &#123;...this.props&#125;/&gt; &lt;/div&gt; ); &#125;&#125;); ReactDOM.render( &lt;div&gt; &lt;Shirt color=&quot;steelblue&quot; num=&quot;3.14&quot; size=&quot;medium&quot;/&gt; &lt;/div&gt;, document.querySelector(&quot;#container&quot;)); It’s not good practice to have all components connect to application state. It is best to have parent/container components connect to state and pass state directly to children. Redux의 4 가지 메서드 store.getState() - 현재 상태 객체 트리를 리턴. store.dispatch(action) - 상태를 바뀌기 위히 액션을 보냄. store.subscribe(listener) - 상태 트리에서 변화를 감지. store.replaceReducer(nextReducer) - 현재 리듀서를 다른 것으로 교체 (advanced). Redux 3가지 원칙 애플리케이션의 state를 위해 단 한개의 store를 사용합니다. 애플리케이션에서 store의 state를 직접 변경할 수 없습니다. state를 변경하기 위해선 무조건 action 이 dispatch 되어야 합니다. action 객체를 처리하는 순수함수를 reducer 라고 부릅니다. reducer는 정보(현재 상태 트리와 액션)를 받아서 어떻게 업데이트 할 지 정의합니다. reducer는 순수함수로 작성되어야 합니다. 즉, 네트워크 및 데이터베이스 접근 불가, 인수 변경 불가. 순수하지않은 API 사용불가 Date.now() Math.random() 카툰 안내서http://bestalign.github.io/2015/10/26/cartoon-intro-to-redux/ 액션 생성자(action creators): 애플리케이션의 상태를 바꾸고 싶다면 항상 액션을 보내야만 하며 유일한 방법입니다. 스토어(store): 상태트리(state tree) 전체를 유지하는 책임을 지며, 액션이 들어왔을 때 어떤 상태변화가 필요한지에 대한일은 reducer에게 위임한다. 리듀셔(the reducers): 스토어는 액션이 어떤 상태 변화를 만드는지 알 필요가 있을 때 리듀서에게 묻는다. 리듀서는 넘겨받은 예전 상태를 변경하지 않고 새로운 복사본을 만든 후 모든 변경사항을 적용한다. 리듀서는 복사되고 업데이트된 상태 객체를 루트 리듀서에게 넘겨주고, 루트 리듀서는 이 객체를 스토어로 보낸다. 똑똑한 컴포넌트: 액션 처리를 책임진다. 자기 자신의 CSS style을 가지지 않는다. 자신의 DOM을 거의 가지고 있지 않는다. 뷰 레이어 바인딩(the view layer binding): 스토어를 뷰에 연결하기 위한 도움장치. 동작방법 스토어를 준비: 루트 컴포넌트는 createStore()를 이용해서 스토어를 생성하고 무슨 리듀서를 사용할지 알려준다. 필요한 모든 리듀서를 combineReducers()를 이용해서 하나로 묶는다. 루트 컴포넌트는 공급 컴포넌트로 서브 컴포넌트를 감싸고 스토어와 공급 컴포넌트 사이를 연결한다. 똑똑한 컴포넌트는 connect()로 네트워크에 연결한다. 이를 통해 상태 업데이트를 받을 수 있게 만든다. 액션콜백 준비: 멍청한 컴포넌트가 액션과 쉽게 일할 수 있게 bindActionCreators()로 액션 콜백을 준비. 데이터흐름 뷰가 액션을 요청한다. (Image) bindActionCreators()가 준비과정에서 사용되었으면 자동으로 액션이 보내진다. 스토어가 액션을 받는다. 현재 애플리케이션 상태 트리와 액션을 루트 리듀서에게 보낸다. 루트 리듀서는 상태 트리를 조각으로 나눈 뒤 알맞은 서브 리듀서로 상태 조각들을 넘겨준다. 서브 리듀서는 받은 상태 조각을 복사한 뒤, 그 복사본을 변경한다. 루트 리듀서에게 변경된 복사본을 돌려준다. 모든 변경된 조각들을 돌려주면, 루트 리듀서는 조각들을 하나로 모아 상태 트리로 만든 뒤 스토어로 돌려준다. 스토어는 새로운 상태 트리를 옛날 상태 트리와 바꾼다. 스토어는 뷰 레이어 바인딩에게 애플리케이션 상태가 변경되었다는 것을 알린다. 뷰 레이어 바인딩은 스토어에게 새로운 상태를 보내달라고 요청한다. 뷰 레이어 바인딩은 뷰에게 화면을 업데이트하도록 요청한다. 프로젝트 준비https://www.youtube.com/watch?v=rNhstoL9MME&amp;list=PL9FpF_z-xR_GMujql3S_XGV2SpdfDBkeC&amp;index=23 폴더구조1234567891011121314src ㄴactions ㄴActionTypes.js ㄴindex.js ㄴcomponents ㄴApp.js ㄴControl.js ㄴCounter.js ㄴValue.js ㄴreducers ㄴcounter.js ㄴindex.js ㄴui.js ㄴindex.js actions리덕스로 보내질 객체를 리턴합니다. 리턴되는 객체는 dispatch 될 때 인자로 전달됩니다.1234//ActionTypes.jsexport const INCREMENT = &quot;INCREMENT&quot;;export const DECREMENT = &quot;DECREMENT&quot;;export const SET_COLOR = &quot;SET_COLOR&quot;; 123456789101112131415161718192021//index.jsimport * as types from &apos;./ActionTypes&apos;;export function increment() &#123; return &#123; type: types.INCREMENT &#125;;&#125;export function decrement() &#123; return &#123; type: types.DECREMENT &#125;;&#125;export function setColor(color) &#123; return &#123; type: types.SET_COLOR, color &#125;;&#125; components123456789101112131415//App.jsimport React, &#123; Component &#125; from &apos;react&apos;;import Counter from &apos;./Counter&apos;;class App extends Component &#123; render() &#123; return( &lt;Counter/&gt; ); &#125;&#125;export default App; 1234567891011121314151617181920212223242526272829303132333435//Control.jsimport React, &#123; Component, PropTypes &#125; from &apos;react&apos;;const propTypes = &#123; onPlus: PropTypes.func, onSubtract: PropTypes.func, onRandomizeColor: PropTypes.func&#125;;function createWarning(funcName) &#123; return () =&gt; console.warn(funcName + &apos; is not defined&apos;);&#125;const defaultProps = &#123; onPlus: createWarning(&apos;onPlus&apos;), onSubtract: createWarning(&apos;onSubtract&apos;), onRandomizeColor: createWarning(&apos;onRandomizeColor&apos;)&#125;;class Control extends Component &#123; render() &#123; return( &lt;div&gt; &lt;button onClick=&#123;this.props.onPlus&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;this.props.onSubtract&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;this.props.onRandomizeColor&#125;&gt;Randomize Color&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;Control.propTypes = propTypes;Control.defaultProps = defaultProps;export default Control; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Counter.jsimport React, &#123; Component &#125; from &apos;react&apos;;import Value from &apos;./Value&apos;;import Control from &apos;./Control&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;// import &#123; connect, bindActionCreators &#125; from &apos;redux&apos;;import * as actions from &apos;../actions&apos;;class Counter extends Component &#123; constructor(props) &#123; super(props); this.setRandomColor = this.setRandomColor.bind(this); &#125; setRandomColor() &#123; const color = [ Math.floor((Math.random()*55) + 200), Math.floor((Math.random()*55) + 200), Math.floor((Math.random()*55) + 200) ]; this.props.handleSetColor(color); &#125; render() &#123; const color = this.props.color; const style = &#123; background: `rgb($&#123;color[0]&#125;, $&#123;color[1]&#125;, $&#123;color[2]&#125;)` &#125;; return( &lt;div style=&#123;style&#125;&gt; &lt;Value number=&#123;this.props.number&#125;/&gt; &lt;Control onPlus=&#123;this.props.handleIncrement&#125; onSubtract=&#123;this.props.handleDecrement&#125; onRandomizeColor=&#123;this.setRandomColor&#125; /&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; number: state.counter.number, color: state.ui.color &#125;;&#125;;const mapDispatchToProps = (dispatch) =&gt; &#123; //return bindActionCreators(actions, dispatch); return &#123; handleIncrement: () =&gt; &#123; dispatch(actions.increment())&#125;, handleDecrement: () =&gt; &#123; dispatch(actions.decrement())&#125;, handleSetColor: (color) =&gt; &#123; dispatch(actions.setColor(color))&#125; &#125;;&#125;;// 두 개의 인수를 받으며 리덕스 스토어와 컴포넌트를 연결하는 함수를 반환합니다.export default connect(mapStateToProps, mapDispatchToProps)(Counter); 1234567891011121314151617181920212223242526//Value.jsimport React, &#123; Component, PropTypes &#125; from &apos;react&apos;;const propTypes = &#123; number: PropTypes.number&#125;;const defaultProps = &#123; number: -1&#125;;class Value extends Component &#123; render() &#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.props.number&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;Value.propTypes = propTypes;Value.defaultProps = defaultProps;export default Value; reducers1234567891011121314151617181920212223242526272829303132//counter.jsimport * as types from &apos;../actions/ActionTypes&apos;;// 애플리케이션의 초기 상태를 나타냅니다.const initialState = &#123; number: 0, dummy: &apos;dumbdumb&apos;, dumbObject: &#123; d: 0, u: 1, m: 2, b: 3 &#125;&#125;;export default function counter(state = initialState, action) &#123; /* ... */ switch(action.type) &#123; case types.INCREMENT: return &#123; ...state, number: state.number + 1, dumbObject: &#123; ...state.dumbObject, u: 0 &#125; &#125;; case types.DECREMENT: return &#123; ...state, number: state.number - 1 &#125;; default: return state; &#125;&#125; 1234567891011//index.jsimport &#123; combineReducers &#125; from &apos;redux&apos;;import counter from &apos;./counter&apos;;import ui from &apos;./ui&apos;;const reducers = combineReducers(&#123; counter, ui&#125;);export default reducers; 12345678910111213141516//ui.jsimport * as types from &apos;../actions/ActionTypes&apos;;const initialState = &#123; color: [255, 255, 255]&#125;;export default function ui(state = initialState, action) &#123; if(action.type === types.SET_COLOR) &#123; return &#123; color: action.color &#125;; &#125; else &#123; return state; &#125;&#125; index.js123456789101112131415161718192021222324252627import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./components/App&apos;;import &#123; createStore &#125; from &apos;redux&apos;;import reducers from &apos;./reducers&apos;;//Provider 컴포넌트는 React store를 모든 자식 컴포넌트에 제공import &#123; Provider &#125; from &apos;react-redux&apos;;//스토어를 생성하여 상태변화를 감지할 수 있으며 액션을 보낼 수 있음const store = createStore(reducers);console.log(store.getState());store.subscribe(() =&gt; console.log(store.getState()));store.dispatch(actions.increment());store.dispatch(actions.decrement());store.dispatch(actions.setColor([200, 200, 200]));ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); sources https://github.com/shlee1353/phostalgia/tree/demo (advanced example) http://lorenstewart.me/2016/11/27/a-practical-guide-to-redux/ https://www.kirupa.com/react/transferring_properties.htm","categories":[],"tags":[]}]}