<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ryan Lee</title>
    <link>https://shlee1353.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 26 Sep 2019 11:48:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>래스터(Raster) 이미지와 백터(Vector) 이미지 for CSS 속성</title>
      <link>https://shlee1353.github.io/2019/09/26/css-raster-vector/</link>
      <guid>https://shlee1353.github.io/2019/09/26/css-raster-vector/</guid>
      <pubDate>Thu, 26 Sep 2019 01:31:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/css-raster-vector/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;일상속에서 휴대폰으로 찍은 사진은 어떤 이미지 타입으로 저장이 될까요? 이 물음에 답하기 위해서는 먼저 이미지 파일에 대한 기본적인 이해가 필요
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/css-raster-vector/1.png" alt=""></p><p>일상속에서 휴대폰으로 찍은 사진은 어떤 이미지 타입으로 저장이 될까요? 이 물음에 답하기 위해서는 먼저 이미지 파일에 대한 기본적인 이해가 필요합니다. 우리가 컴퓨터 모니터 상에서 사용하는 그래픽은 크게 <code>Raster</code>와 <code>Vector</code> 두 가지 타입으로 존재합니다. 많은 이미지들이 이 두가지 형태로 생성되며 때로는 매우 비슷하거나 동일하게 보일때도 있습니다. 하지만, 이 둘은 분명한 차이점이 존재하며, 용도에 맞게 사용해야할 필요가 있습니다.</p><p><img src="/image/css-raster-vector/2.png" alt=""></p><p><code>Raster</code>의 또 다른 명칭은 <code>비트맵(bitmaps)</code>이며 <code>RGB(red, green, blue)</code> 색상값을 가진 하나의 픽셀(점)들이 모여 이미지를 만들어냅니다. 작은 픽셀들이 모여 이미지를 화면에 출력하기 때문에 생생하고 세밀한 표현이 가능하다는 장점을 가지고 있습니다. 그렇기 때문에, 디지털화된 사진이나 미술작품처럼 풍부한 컬러감과 자연스러운 그라데이션이 필요한 곳에 주로 사용되며, <code>JPG, GIF, PNG</code> 파일이 여기에 속합니다.</p><p><img src="/image/css-raster-vector/3.png" alt=""></p><p><code>Raster</code>이미지의 선명도는 <code>PPI(Pixels-per-inch)</code>로 나타내며 이는 1인치 정사각형안에 몇 개의 픽셀을 담고 있는지를 나타냅니다. 예를들어, 1 PPI는 1x1=1개, 2 PPI는 2x2=4개, 4 PPI는 4x4=16개의 픽셀로 이루어져 있으며, 인쇄물 용도로 제작하는 이미지는 최소 300PPI를 요구합니다. 여기서 중요한점은, 높은 PPI로 이미지를 제작했더라도 그것을 출력하는 디바이스 해상도와는 아무런 관련이 없다는 것입니다. 오히려, PPI는 이미지 혹은 사진 파일을 프린터로 출력할 때 고려해야 할 부분입니다.</p><p><img src="/image/css-raster-vector/4.png" alt=""></p><p>디바이스의 해상도를 나타낼 때는 주로 <code>1280x720, 1920x1080</code> 표기를 사용하며, 이는 가로와 세로 화면에 들어가는 총 픽셀수를 의미합니다. 화면상에서 이미지의 사이즈를 결정짓는건 단 두 가지가 있습니다. 바로, <strong>이미지의 실제 넓이와 높이</strong><code>(pixel dimensions)</code>, 그리고 <strong>디바이스의 해상도</strong>입니다.</p><p><img src="/image/css-raster-vector/5.png" alt=""></p><p>예를들어, <code>440x550</code> 사이즈로 제작된 캐릭터 이미지가 있다고 하면, 모니터의 실제 사이즈는 동일하지만, 해상도가 높은 화면에서 출력할 경우 더욱더 작게 보여 선명한 상태로 인식하게 됩니다. PPI를 아무리 높여도 보이는 결과는 달라지지 않습니다. 고해상도의 이미지를 출력할 경우 높은 PPI는 필요조건이지만 그만큼 이미지 파일의 사이즈는 커지게 됩니다. 또한, 일정 픽셀 안에 고정된 컬러값과 사이즈를 가지고 있기 때문에 이미지를 확대할 경우 깨짐 현상이 발생합니다. 이러한 단점들을 보완한 것이 바로 <code>Vector</code>기반 이미지입니다.</p><p><img src="/image/css-raster-vector/6.png" alt=""></p><p><code>Vector</code> 그래픽은 기본적으로 <code>꼭지점과 연결된 선(vertices and paths)</code>으로 구성되어 있으며 이를 사용하여 다각형, 사각형, 원 등과 같은 기하학적 요소들을 만들어냅니다. 기본적으로, 하나의 <code>점(point)</code>으로 시작되며 두 개의 점을 선으로 이으면 이것을 <code>path</code>라고 부릅니다. 여러 꼭지점으로 연결된 paths의 한 곳이 닫히면 기하학적 패턴 또는 도형이 완성됩니다.</p>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/09/26/css-raster-vector/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트(React) Lottie 애니메이션 적용</title>
      <link>https://shlee1353.github.io/2019/09/23/react-lottie/</link>
      <guid>https://shlee1353.github.io/2019/09/23/react-lottie/</guid>
      <pubDate>Mon, 23 Sep 2019 08:52:26 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/react-lottie/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Lottie는 After Effects 애니메이션을 실시간으로 렌더링하는 iOS, Android 및 React Native 라이브러리입니다. 평소, gi
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/react-lottie/1.png" alt=""></p><p>Lottie는 After Effects 애니메이션을 실시간으로 렌더링하는 iOS, Android 및 React Native 라이브러리입니다. 평소, gif, css 애니메이션을 사용한 결과물보다 더욱더 만족스러운 퀄리티를 만들어 낼 수 있다는 장점을 가지고 있습니다. 또 다른 장점으로는 디자이너가 원하는 완성된 결과물을 바로 적용하기 때문에, 개발자가 애니메이션에 구현에 대한 시간과 노력을 절약할 수 있습니다. 애니메이션에 대한 모든 정보가 JSON 파일로 저장되기 때문에 특별한 프로그램 설치가 필요없습니다.<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Lottie <span class="keyword">from</span> <span class="string">'react-lottie'</span>;</span><br><span class="line"><span class="keyword">import</span> ThumbsUp <span class="keyword">from</span> <span class="string">'../lottie/thumbs-up.json'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lottieOptions = &#123;</span><br><span class="line">  animationData: ThumbsUp,   </span><br><span class="line">  loop: <span class="literal">false</span>,        </span><br><span class="line">  autoplay: <span class="literal">false</span>,   </span><br><span class="line">  rendererSettings: &#123;</span><br><span class="line">    className: <span class="string">'add-class'</span>, <span class="comment">// svg에 적용</span></span><br><span class="line">    preserveAspectRatio: <span class="string">'xMidYMid slice'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThumbsUpComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [isStopped, SetIsStopped] = useState(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> [isPaused, SetIsPaused] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onStop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">SetIsStopped(!isStopped)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onPause = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">SetIsPaused(!isPaused)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div className=<span class="string">"thumbs-up"</span>&gt;</span><br><span class="line">&lt;Lottie</span><br><span class="line">options=&#123;lottieOptions&#125;</span><br><span class="line">isStopped=&#123;isStopped&#125;</span><br><span class="line">isPaused=&#123;isPaused&#125;</span><br><span class="line">isClickToPauseDisabled=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">style=&#123;&#123;<span class="attr">width</span>: <span class="string">'300px'</span>, <span class="attr">height</span>: <span class="string">'300px'</span>&#125;&#125; <span class="comment">// svg의 부모 div에 적용</span></span><br><span class="line">eventListeners=&#123;[</span><br><span class="line">&#123;</span><br><span class="line">eventName: <span class="string">'complete'</span>,</span><br><span class="line">callback: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'the animation completed'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">]&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;button onClick=&#123;onPause&#125;&gt;Play/Pause&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThumbsUpComponent;</span><br></pre></td></tr></table></figure></p><p>그럼 어떤 단점을 가지고 있을까요? 오로지 After Effect으로 생성이 가능하기 때문에 진입장벽이 있을 수 있습니다. 애니메이션 오브젝트에만 생성 가능하며, 전체 화면의 트렌지션효과는 적용이 불가능합니다.</p><p><img src="/image/react-lottie/2.gif" alt=""></p><ul><li><a href="https://www.npmjs.com/package/react-lottie" target="_blank" rel="external">https://www.npmjs.com/package/react-lottie</a></li><li><a href="https://lottiefiles.com/" target="_blank" rel="external">https://lottiefiles.com/</a></li></ul>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/09/23/react-lottie/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS속성 Clipping과 Masking 차이점과 특징</title>
      <link>https://shlee1353.github.io/2019/07/15/css-clip-mask/</link>
      <guid>https://shlee1353.github.io/2019/07/15/css-clip-mask/</guid>
      <pubDate>Mon, 15 Jul 2019 05:24:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/css-clip-mask/0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;평소 &lt;code&gt;clipping&lt;/code&gt;과 &lt;code&gt;masking&lt;/code&gt; 속성의 차이점을 알고 계시나요? CSS 속성을 다시 공부할 때마다,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/css-clip-mask/0.png" alt=""></p><p>평소 <code>clipping</code>과 <code>masking</code> 속성의 차이점을 알고 계시나요? CSS 속성을 다시 공부할 때마다, “아, 이런게 있었구나!”할 정도로, 매번 업무에 적용하기에는 특별한 속성인 것 같습니다. 우선, 결론적으로, 두 속성의 차이점은 <code>clipping</code>은 <strong>벡터 패스</strong>이고, <code>masking</code>은 <strong>래스터 이미지</strong>입니다.</p><p><img src="/image/css-clip-mask/1.png" alt=""></p><ul><li><strong>벡터(Vector)</strong>는 점과 점 사이의 곡선으로 이미지를 구현하는 방식으로, 기본적인 점의 위치 정보만 저장하기 때문에 파일의 크기가 작습니다. 또한, 이미지 축소/확대 시에도 손상을 주지 않는 장점이 있습니다.</li><li><strong>래스터(Raster)</strong> 이미지는 정사각형 모양의 픽셀(Pixel) 수백개가 모여 전체 이미지를 구성하는 방식입니다. 한 공간에 사용된 모자이크 픽셀 수에 따라서 이미지의 해상도가 달라집니다.</li></ul><p>Clips은 항상 벡터 패스로 이루어져있습니다. 패스의 바깥쪽은 투명도가 적용되며, 안쪽은 불투명 영역입니다.</p><p><img src="/image/css-clip-mask/2-1.png" alt=""></p><p>mask는 아래와 같이 그라데이션이 적용된 정사각형을 생각하면 이해가 쉽습니다. 마스크 타입에 따라, 검정색과 흰색 부분에 각각 투명도/불투명도가 적용됩니다.</p><p><img src="/image/css-clip-mask/2-2.png" alt=""></p><h2 id="clip-속성"><a href="#clip-속성" class="headerlink" title="clip 속성"></a>clip 속성</h2><p>우선 가장 기본적인 clip 속성에 대해 알아보도록 하겠습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  clip: rect(10px, 20px, 30px, 40px); // 상 우 하 좌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clip 속성은 현재 <code>deprecated</code> 되었으며, 새로운 속성이 추가되어 더 이상 추천하지 않습니다. 또한, clip은 쉽게 사용하기 어려운 두 가지 제약이 있습니다.</p><ul><li>엘리먼트에 <code>absolute</code> 속성이 적용되어야 합니다.</li><li>직사각형 형태로만 적용 가능합니다.</li></ul><h2 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h2><p><code>clip-path</code>는 새롭게 추가된 속성으로 여러 형태의 도형을 적용할 수 있다는 장점이 있습니다. 물론, 다양한 도형을 적용하려면 브라우저 호환성을 꼭 확인해야 합니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clip-circle</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(40px at center);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clip-ellipse</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">ellipse</span>(130px 140px at 10% 20%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clip-polygon</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(50% 0, 100% 50%, 50% 100%, 0 50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/css-clip-mask/3.png" alt=""></p><p><code>polygon()</code> 속성을 사용하여 원하는 모양을 만들 수 있는데요, 이것을 좀 더 쉽게 적용하려면 <a href="https://bennettfeely.com/clippy/" target="_blank" rel="external">Clippy</a>를 사용하는 것을 추천드립니다. Clippy을 사용하여 네이버 로고가 들어간 간단한 인터렉션을 구현해 보도록 하겠습니다.</p><p><img src="/image/css-clip-mask/4.gif" alt=""></p><h2 id="mask-속성"><a href="#mask-속성" class="headerlink" title="mask 속성"></a>mask 속성</h2><p><code>Masking</code>은 시각적으로 엘리먼트(이미지 객체)의 일정/전체 부분을 숨기는데 사용됩니다. mask-image 속성을 기본으로 mask-mode, mask-repeat, mask-position, mask-size 등 다양한 속성값을 가지고 있습니다. 각각의 mask는 <strong>mask layer</strong>를 형성하는데요, 두 가지 타입 중 하나를 선택할 수 있습니다. <code>alpha</code> 또는 <code>luminance</code> 입니다.</p><ul><li><strong>Alpha Masks</strong>는 알파채널을 가지고 있으며 알파값은 mask 값으로 사용됩니다. 알파채널의 가장 간단한 예로 검정과 투명 영역이 있는 png 이미지를 예로들 수 있습니다.</li></ul><p><img src="/image/css-clip-mask/5.png" alt=""></p><p>알파채널은 투명도 정보를 가지고 있는 픽셀데이터의 집합이며 두 픽셀값이 겹쳐져 만났을 때 픽셀의 컬러값을 결정합니다. 위 이미지경우, 검정색은 1이라는 알파값을 가지고 있으며, 투명영역은 0의 알파값을 가지고 있습니다. 알파값을 가지고 있는 이미지를 mask 속성으로 사용할 경우, 검정색 영역에 엘리먼트가 노출되고 투명영역에는 미노출 됩니다.</p><p><img src="/image/css-clip-mask/6.png" alt=""></p><ul><li><strong>Luminance Masks</strong>는 이미지의 luminance 값을 사용한다는 것을 제외하고는 alpha mask와 유사합니다. alpha mask의 검정색 부분이 흰색으로 바뀌었다고 생각하면 됩니다.</li></ul><p><img src="/image/css-clip-mask/7.png" alt=""></p><p>예를들어, object에 luminance mask를 적용하면, 흰색 부분으로 masked object가 나타나는 것을 확인할 수 있습니다.</p><p><img src="/image/css-clip-mask/8.png" alt=""></p><p>png, svg파일을 이용해서 mask를 만들 수도 있지만, <code>gradient</code> 효과를 사용하여 좀 더 간편하게 mask를 적용하는 방법에 대해 알아보도록 하겠습니다.</p><p><img src="/image/css-clip-mask/9.png" alt=""></p><p><code>background-image</code> 속성에 <code>linear-gradient</code>를 적용하면 간단한 mask 효과를 적용할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://lorempixel.com/1920/480/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(270deg, rgba(0, 0, 0, 0) <span class="number">50%</span>, <span class="built_in">rgba</span>(0, 0, 0, 1) <span class="number">95%</span> );</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom, rgba(0, 0, 0, 0) <span class="number">50%</span>, <span class="built_in">rgba</span>(0, 0, 0, 1) <span class="number">95%</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mask효과는 clip보다 자연스러운 화면전환 효과가 가능하기 때문에 인터렉션과 비주얼이 중요시되는 웹사이트 제작에 자주 사용되고는 합니다. mask는 보다 화려한 효과를 동반하기 때문에 브라우저 호환성 체크는 필수입니다. 지금까지 간략하게 Clipping과 Masking애 대해 알아봤습니다:)</p>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/15/css-clip-mask/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS 애니메이션(Animation) 실제로 어떻게 쓰나?</title>
      <link>https://shlee1353.github.io/2019/07/11/css-animation/</link>
      <guid>https://shlee1353.github.io/2019/07/11/css-animation/</guid>
      <pubDate>Thu, 11 Jul 2019 05:18:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/css-animation/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/image/css-animation/2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;현재, 네이버 예약은 앉은 자리에서 주문과 결제를 한 번에 진행할 수 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/css-animation/1.png" alt=""><br><img src="/image/css-animation/2.png" alt=""><br>현재, 네이버 예약은 앉은 자리에서 주문과 결제를 한 번에 진행할 수 있는 로컬페이 CBT를 진행중에 있습니다(보시면 많이 이용해주세요^^). 이번 로컬페이 UI개발을 진행하면서 개인적으로 가장 중점을 둔 부분이 애니메이션 입니다. 애니메이션 효과는 사용자로 하여금 인터렉션에 대한 피드백은 물론 소소한 재미를 선사해 줍니다. 아래는 이번 로컬페이에 적용한 애니메이션 화면입니다.</p><p><img src="/image/css-animation/3.gif" alt=""></p><p>애니메이션은 크게 세 부분에 적용되어 있습니다.</p><ol><li>수량 선택 후, 담기 버튼을 누르면 해당 메뉴 우측에 있는 카트가 초록색으로 변하면서, 수량 표시.</li><li>하단 주문하기 버튼의 배경색이 변하면서, 비어 있던 카트가 흰색으로 변하면서 수량 표시와 함께 반동 애니메이션 적용.</li><li>테이블주문/포장주문 선택 시, 상단 배경이 바뀌면서 가운데 두 아이콘이 스와이프 형태로 이동.</li></ol><p>한 화면에 적용된 애니메이션이 평소 팝업/로딩바에 비하면 상당히 많은 걸 알 수 있습니다.</p><p><strong>animation-timing-function</strong></p><p><img src="/image/css-animation/4.png" alt=""></p><p>UI개발을 진행하면서 웹상에서 애니메이션을 표현하기 위해 가장 기본적인 방법은 연속의 PNG이미지를 만들어서 <code>animation-timing-function</code>의 <code>step-start</code>를 적용할 수 있습니다. 간단한 방법이지만, 애니메이션의 시퀀스가 길어질수록 PNG이미지 관리가 어렵고 각각의 이동에 대한 <code>background-position</code>을 설정해 줘야하기 때문에 사용의 제한이 있습니다. 또한, 색상과 사이즈를 수정하는데 어려움이 있습니다. 그렇기 때문에, 반복하는 짧은 길이의 로딩바를 표현하기에 적당합니다. 연속된 이미지를 하나의 움직이는 파일로 만든게 GIF 파일이며, 이 또한 많이 사용하고 있지만 성능 최적화를 위한 최선의 방법은 아닙니다.</p><p><strong>CSS animation</strong></p><p><img src="/image/css-animation/5.gif" alt=""></p><p>PNG, GIF 파일 등 화면을 구성하는 파일이 많아 질수록 HTTP1.1일 경우 리소스 요청 증가 및 성능 이슈가 생길 수 있습니다. 간단한 로딩바와 같은 애니메이션은 CSS 스타일로 충분히 구현 가능합니다. CSS 스타일로 구현이되어 있기 때문에 색상, 사이즈, 굵기, 추가효과 구현이 용이합니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 로딩 CSS 애니메이션 구현 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loader</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">210px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">210px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, #00cf5b 10%, rgba(255, 255, 255, 0) <span class="number">42%</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, #00cf5b 10%, rgba(255, 255, 255, 0) <span class="number">42%</span>);</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: load <span class="number">1s</span> infinite linear;</span><br><span class="line">    <span class="attribute">animation</span>: load <span class="number">1s</span> infinite linear;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.loader</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00cf5b</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.loader</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">95%</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> load &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(0deg);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>처음 로컬페이 애니메이션 가이드 영상을 받았을 때, 어떤 방법으로 구현이 가능할지 검토를 하였습니다. 우선 연속된 PNG이미지를 이용해서 구현 하기에는 복잡도가 높고, 그라데이션 효과까지 들어가 있어 용량이 생각보다 커질 수가 있습니다. 더불어 디테일한 아이콘은 물론 선택한 수량까지 실시간으로 반영해야해서 100% CSS 애니메이션으로 그려서 적용하는건 더욱더 불가능합니다.</p><p><img src="/image/css-animation/6.png" alt=""></p><p>그럼, 디자이너로 부터 움직이는 모든 애니메이션의 GIF파일을 받는다? HTML로 영역만 잡고 전달받은 파일만 추가하면 되기 때문에 가장 간단한 방법입니다. 하지만, 이것역시 가장 좋은 방법은 아닌 것 같다는 생각이 들었습니다. 마지막 남은 방법은 최소한의 아이콘 이미지 + CSS 스타일/애니메이션 이었습니다.</p><p><code>Lottie in React</code>도 시험삼아 사용하고 싶었지만, 에프터이펙트를 통해서 JSON파일을 전달 받아야해서 오히려 작업 프로세스가 늘어나서 이번 프로젝트에서는 사용을 못했습니다.</p><p>개발자 마다 구현하는 방법과 순서가 다르겠지만, 우선 저는 큰 동작 단위로 애니메이션을 분류해봤습니다.</p><ul><li>좌우이동</li><li>이동 시 약간의 회전(기울기)</li><li>색반전 + 아이콘 변경</li><li>짧은 막대 효과</li></ul><p>총 4가지의 효과를 순서대로 잘 적용을 하면 되겠구나 생각했습니다. 그리고 리액트로 진행된 프로젝트라서 최소한의 state 값으로 애니메이션의 상태를 관리하면 좋을 것 같았습니다. 우선 영역을 잡아 보도록 하겠습니다.</p><p><img src="/image/css-animation/7.png" alt=""></p><p>애니메이션이 적용되는 영역을 만들었으니 전달받은 인터렉션 가이드와 최대한 비슷하게 CSS 애니메이션만 적용하면 됩니다! 복잡하게 보이는 애니메이션도 알고보면 간단한 인터렉션의 조합으로 이루어져 있습니다^0^</p><p><img src="/image/css-animation/8.png" alt=""></p><p>다음으로 생각할 것은, 인터렉션을 적용하기 위해서 <code>transition</code> 또는 <code>animation</code>을 선택해야 합니다. 좌우이동같은 경우는 인터렉션이 진행되는 동안 단순히 좌/우 위치값만 변경되기 때문에 <code>transition</code>을 사용해야합니다. 반면, 기울기 효과는 (기울기X -&gt; 기울기O -&gt; 기울기X) 세 단계로, 인터렉션이 진행되는 중간에 기울기를 추가해줘야 하기 때문에 <code>animation</code>을 사용해야합니다. 이 두 속성만 주의해서 감각적(?)으로 잘 적용하신다면 애니메이션 정복! -끝-</p>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/11/css-animation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PhantomJS 웹 스크린 캡쳐기능 사용</title>
      <link>https://shlee1353.github.io/2019/07/11/phantom-web-screen/</link>
      <guid>https://shlee1353.github.io/2019/07/11/phantom-web-screen/</guid>
      <pubDate>Thu, 11 Jul 2019 02:47:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/phantom-web-screen/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;PhamtomJS는 헤드리스 브라우저(사용자 인터페이스 미제공)이며 웹페이지 자동화에 사용됩니다. 브라우저(IE, Chrome, Safari,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/phantom-web-screen/1.png" alt=""></p><p>PhamtomJS는 헤드리스 브라우저(사용자 인터페이스 미제공)이며 웹페이지 자동화에 사용됩니다. 브라우저(IE, Chrome, Safari, etc.) 화면없이 자바스크립트 API를 통해 웹을 컨트롤 할 수 있는 강력한 도구입니다. 오늘은, 팬텀JS의 다양한 기능 중 스크린 캡쳐에 대해 알아 보도록 하겠습니다. 서비스 개발 시 스크린 캡쳐는 왜 필요한가? 에 대한 답변은 아래 링크 참고 하도록 하겠습니다.</p><p><a href="https://m.search.naver.com/search.naver?query=%EC%8B%9D%EB%8B%B9&amp;where=m&amp;sm=mtp_hty" target="_blank" rel="external">스크린 캡쳐 활용 예시</a></p><p><img src="/image/phantom-web-screen/2.png" alt=""></p><p>지도영역 안에 들어간 A, B, C 마커가 표시된 지도는 png 이미지 파일입니다. 사용자가 화면 접속시 서버에서 네이버 지도와 마커를 사용해서 화면을 만들어 주고 필요한 영역만큼만 캡쳐를 해서 background-image 속성에 추가하는 과정을 거치게됩니다. 이렇게, 팬텀JS를 활용하면 브라우저 화면없이 스크린캡쳐가 가능합니다.</p><h2 id="팬텀JS-맛보기"><a href="#팬텀JS-맛보기" class="headerlink" title="팬텀JS 맛보기"></a>팬텀JS 맛보기</h2><p>팬텀JS는 강력한 기능을 가지고 있지만 사용하기가 매우 용이합니다. 다양한 설치 방법이 있지만, brew를 통해 단 한 줄로 설치할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install phantomjs</span><br></pre></td></tr></table></figure><p>글로벌로 설치되었기 때문에 Node.js처럼 어디서든 명령어 실행이 가능합니다. 우선, 빈 폴더에 test.js 파일을 만든 뒤 아래와 같이 코드를 작성합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js 파일</span></span><br><span class="line"><span class="keyword">var</span> system = <span class="built_in">require</span>(<span class="string">'system'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(system.args[<span class="number">0</span>]); <span class="comment">// test.js</span></span><br><span class="line"><span class="built_in">console</span>.log(system.args[<span class="number">1</span>]); <span class="comment">// arg1</span></span><br><span class="line"><span class="built_in">console</span>.log(system.args[<span class="number">2</span>]); <span class="comment">// arg2</span></span><br><span class="line"><span class="built_in">console</span>.log(system.args[<span class="number">3</span>]); <span class="comment">// arg3</span></span><br></pre></td></tr></table></figure><p>커맨드 라인에 $ phantomjs test.js arg1 arg2 arg2를 입력한 후 터미널창을 확인하면 test.js파일이 실행된 것을 알 수 있습니다. 간단한 테스트를 마쳤으니, 스크린 캡쳐 기능을 사용하도록 하겠습니다. capture.js 파일을 생성 한 뒤 아래 코드를 복사 후 붙여넣습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// capture.js 파일</span></span><br><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line"><span class="keyword">var</span> t0 = performance.now();</span><br><span class="line"><span class="keyword">var</span> t1 = <span class="number">0</span>;</span><br><span class="line">page.viewportSize = &#123; <span class="attr">width</span>: <span class="number">1525</span>, <span class="attr">height</span>: <span class="number">1240</span> &#125;;</span><br><span class="line">page.open(<span class="string">'</span></span><br><span class="line"><span class="string">https://www.naver.com/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    page.render(<span class="string">'test.png'</span>);</span><br><span class="line">    t1 = performance.now();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Call to doSomething took "</span> + (t1 - t0) + <span class="string">" milliseconds."</span>)</span><br><span class="line">    phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>첫 번째 행에서 webpage 모듈을 불러와서 viewportSize, open, render 메소드를 순차적으로 사용해서 최종적으로 test.png 파일을 생성하는 과정입니다. 이 외에도, 팬텀JS를 기반으로 Jasmine, QUnit, Mocha 등을 활용한 기능 테스트 및 네트워크 성능 분석 자동화(YSlow, Jenkins)가 가능하며, SVG, Canvas등의 웹컨텐츠도 캡쳐할 수 있습니다.</p>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/11/phantom-web-screen/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트(React) UI 컴포넌트 설계하기</title>
      <link>https://shlee1353.github.io/2019/07/10/react-ui-components/</link>
      <guid>https://shlee1353.github.io/2019/07/10/react-ui-components/</guid>
      <pubDate>Wed, 10 Jul 2019 06:19:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/react-ui-components/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;디자인-amp-인터렉션&quot;&gt;&lt;a href=&quot;#디자인-amp-인터렉션&quot; class=&quot;headerlink&quot; title=&quot;디자인&amp;amp;인
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/react-ui-components/1.png" alt=""></p><h1 id="디자인-amp-인터렉션"><a href="#디자인-amp-인터렉션" class="headerlink" title="디자인&amp;인터렉션"></a>디자인&amp;인터렉션</h1><p>UI개발을 하시면서 많이 접하시는 디자인이며 간단한 인터렉션과 노출조건이 들어가 있습니다. 하나는 상품을 확인할 수 있는 캐로셀 UI 컴포넌트이며, 다른 하나는 각 이미지에 설명이 들어가 있는 리스트 구조의 UI입니다. 초록색 박스로 그러져있는 설명 부분은 일정 높이에서 펼치기 버튼이 노출됩니다.</p><p><img src="/image/react-ui-components/2.png" alt=""></p><p>우선, 매우 간단한 구조이며, 기존에 리액트로 업무를 하시면서 setState 메소드와 간단한 반복문(map)을 사용하셨다면 쉽게 구현이 가능합니다. 저는 다음과 같은 프로세스로 작업을 진행하였습니다.</p><h2 id="캐로셀"><a href="#캐로셀" class="headerlink" title="캐로셀"></a>캐로셀</h2><ul><li>map을 사용하기 위해 필요한 데이터는 무엇이 있는가? 기본적으로 썸네일에 사용되는 상품 이미지가 있습니다.</li><li>다음으로, 상품 이미지 경로가 들어가 있는 초기값을 선언해 놓습니다. 더미 데이터를 만드는 방법은 여러가지가 있지만, 우선 간단 예로 3개 정도만 만들어 보도록 하겠습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = [</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">1</span></span><br><span class="line">        imgUrl: <span class="string">'이미지주소'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">2</span></span><br><span class="line">        imgUrl: <span class="string">'이미지주소'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">3</span></span><br><span class="line">        imgUrl: <span class="string">'이미지주소'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>초기값을 담고 있는 initialState 배열을 실제로 사용해야할 변수에 담아줘야 합니다. 기존에는 이 단계에서 setState 메소드를 사용하였지만, 지금은 useState 를 사용합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [products, setProducts] = useState(initialState)</span><br></pre></td></tr></table></figure><ul><li>useState 메소드 인자로 initialState를 넘겨주며 이 값은 products에 담기게 됩니다.</li><li>이제 기존처럼 map을 사용하여 캐로셀에 들어가는 상품 이미지가 담긴 UI를 생성할 수 있습니다. 생각보다 쉽게 적용이 가능합니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Product = <span class="function">(<span class="params">&#123; imgUrl &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">        &lt;li className=<span class="string">"item"</span>&gt;</span><br><span class="line">            &lt;a href=<span class="string">"#"</span> className=<span class="string">"product"</span>&gt;</span><br><span class="line">                &lt;img src=&#123;imgUrl&#125; className=<span class="string">"img"</span> width=<span class="string">"100"</span> height=<span class="string">"100"</span> alt=<span class="string">"이미지"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&lt;ul className=<span class="string">"product_list"</span>&gt;</span><br><span class="line">    &#123;products.map(<span class="function"><span class="params">product</span> =&gt;</span> (</span><br><span class="line">        &lt;Product</span><br><span class="line">            key=&#123;product.id&#125;</span><br><span class="line">            imgUrl=&#123;product.imgUrl&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><h2 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a>리스트</h2><p>사실, 리스트와 캐로셀을 작업하는데 큰 차이는 없습니다. 다만, 조건식이 더해졌을 때, UI개발에서 어느정도 수준의 인터렉션 개발이 가능한지 보여드리려고 합니다. 복잡한 인터렉션이 아니라면 간단한 것은 직접 개발을 하면 좋을 것 같습니다. 물론, 실제 개발을 진행하면서 수정/삭제 될 수는 있지만, 리액트와 같은 자바스크립트 프레임워크/라이브러리를 이해하는데 큰 도움이 됩니다.</p><ul><li>초록색 박스 설명의 내용이 두 줄 이상일 경우 height:40px 펼치기 버튼이 노출된다.</li><li>펼치기 버튼을 누르면 해당 초록색 박스의 높이값이 auto가 되면서 펼쳐진다.</li></ul><p><img src="/image/react-ui-components/3.png" alt=""><br>예로, 이미지 리스트를 만들기 위해 아래와 같은 인터렉션 조건이 있습니다.</p><p>위와같은 인터렉션 조건을 코드로 어떻게 풀어나갈 수 있을까요? 다음과 같은 순서로 생각할 수 있습니다.</p><ol><li>펼치기 버튼은 첫 랜더링시 결정되어 사용자에게 보여줘야합니다.</li><li>그러기 위해서는, 초록색 설명 박스의 높이값을 알고 있어야합니다.</li><li>이때 사용할 수 있는 것이 <code>useRef</code> 이며, 이는 jQuery의 선택자와 같은 기능을 합니다.</li><li>useRef로 초록색 설명 박스를 선택하고, 기존에 사용하였던 <code>componentDidMount</code> 대신에 <code>userEffect</code>를 사용하여 각각의 설명박스 높이값을 저장합니다.</li><li>저장된 높이값을 기준으로 height:40px 이상일 경우 펼침 버튼을 노출하는 조건문을 추가합니다.</li><li>펼침 버튼을 눌렀을 시 height값을 auto로 바꿔주는 것은 useRef로 선택한 엘리먼트에 기존처럼 open 클래스를 추가하면 됩니다. 지금까지 설명한 내용을 코드로 살펴보도록 하겠습니다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [infoHeight, setInfoHeight] = useState([])</span><br><span class="line"><span class="keyword">const</span> elRef = useRef([])</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e, i</span>) </span>&#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    elRef.current[i].classList.add(<span class="string">'open'</span>)</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setInfoHeight(elRef.current.map(<span class="function"><span class="params">item</span> =&gt;</span> item.clientHeight))</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="keyword">const</span> Image = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">        &lt;li className=<span class="string">"item"</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">"image_box"</span>&gt;이미지&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className="info_box" ref=&#123;el =&gt; elRef.current[i] = el&#125;&gt;설명&lt;/</span>div&gt;</span><br><span class="line">            &#123;infoHeight[i] &gt;= <span class="number">40</span> &amp;&amp;</span><br><span class="line">                &lt;a href=<span class="string">"#"</span> className=<span class="string">"btn"</span> roel=<span class="string">"button"</span> onClick=&#123;e =&gt; handleClick(e, i)&#125;&gt;펼침버튼&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&lt;div className=<span class="string">"image_area"</span>&gt;</span><br><span class="line">    &lt;ul className=<span class="string">"image_list"</span>&gt;</span><br><span class="line">        &#123;images.map(<span class="function">(<span class="params">image, index</span>) =&gt;</span> &#123;</span><br><span class="line">            &lt;Image</span><br><span class="line">                key=&#123;index&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>갑자기 코드량이 많아졌네요! 코드를 한 줄씩 살펴보도록 하겠습니다.</p><ol><li><code>div.info_box</code>에 <code>ref={el =&gt; elRef.current[i] = el}</code>를 추가합니다. 여기서 중요한 것은 useRef 메소드를 통해서 <code>elRef</code> 객체를 생성하면 current 값이 자동으로 생성되며 여기에 선택된 엘리먼트를 순서대로 추가하는 코드입니다.</li><li>그런다음 <code>useEffect</code>를 통하여 저장된 초록박스 설명의 높이값을 가져와서, 상단에 이미 선언해 놓은 infoHeight 배열에 추가합니다.</li><li>이제 배열 안에는 초록박스의 높이값이 전부 담겨 있으며 <code>infoHeight[i] &gt;= 40</code> 조건문을 통하여 펼침버튼 노출/미노출을 결정하게됩니다.</li><li>펼침 버튼에는 <code>onClick={e =&gt; handleClick(e, i)}</code>를 추가하여 클릭시 해당 초록박스에 open 클래스를 추가하여 높이값을 auto로 만들어줍니다. 이부분은 css에 미리 선언해 두셔야합니다.</li></ol><p><strong>실제 서비스 적용 화면</strong></p><p><img src="/image/react-ui-components/4.gif" alt=""></p><p>처음 리액트로 서비스를 시작하시는 분들에게는 다소 복잡한 내용일 수 있지만, 컴포넌트 구조화 및 기본적인 인터렉션만 잘 구현해도 FE협업시 큰 시너지 효과가 있다고 생각합니다.</p>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/10/react-ui-components/#disqus_thread</comments>
    </item>
    
    <item>
      <title>타입스크립트(TypeScript) 기본개념 및 사용방법 정리</title>
      <link>https://shlee1353.github.io/2019/07/05/typescript-basic-concepts/</link>
      <guid>https://shlee1353.github.io/2019/07/05/typescript-basic-concepts/</guid>
      <pubDate>Fri, 05 Jul 2019 05:32:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/typescript-basic-concepts/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/typescript-basic-concepts/1.png" alt=""></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="number">123</span>;</span><br><span class="line">v1 = <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure><p>타입스크립트에서 위와같이 선언시 두 번째 v1은 타입 에러가 발생합니다. 이는 첫 번째 할당 시 문자열이 아닌 숫자가 변수에 담겨서 입니다. 이것을 타입추론(type inference)이라고 합니다. 두 가지 모두 변수에 담기 위해서는 두 가지 타입을 명시해줘야 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">123</span>;</span><br><span class="line">v1 = <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure><p>이처럼 타입스크립트에서는 여러 가지 타입을 정의할 수 있습니다. any 타입은 모든 종류의 값을 허용합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> values: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> values: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [msg, size];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span>;</span><br><span class="line">value = <span class="number">123</span>;</span><br><span class="line">value = <span class="string">'123'</span>;</span><br><span class="line">value = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>열거형 타입</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Fruit &#123;</span><br><span class="line">Apple,</span><br><span class="line">Banana,</span><br><span class="line">Orange,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v1: Fruit = Fruit.Apple;</span><br><span class="line"><span class="keyword">const</span> v2: Fruit.Apple | Fruit.Banana = Fruit.Banana;</span><br></pre></td></tr></table></figure><p>열거형 타입은 객체이며, 각 원소는 값으로 사용될 수 있고, 타입으로 사용될 수도 있습니다. 상수 열겨형 타입을 사용할 경우 컴파일 후에도 남아 있지 않습니다.</p><p><strong>함수 타입</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfoText</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 타입을 정의하기 위해서는 매개변수 타입과 반환 타입이 필요합니다.</p><p><strong>인터페이스</strong></p><p>자바에서의 인터페이스는 클래스를 구현하기 전에 필요한 메서드를 정의하는 용도로 사용됩니다. 타입스크립트에서는 좀 더 다양한 기능을 가지고 있습니다. 인터페이스로 객체 타입을 정의하는 것을 알아보도록 하겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 인터페이스에서 하나 이상의 속성 타입을 만족하지 못하면 타입 에러가 발생합니다. 선택속성을 추가하려면 ? 기호를 사용해야합니다. 읽기 전용일 경우 readonly를 추가하면 됩니다. 정의되지 않은 속성값을 할당할 경우 타입 에러가 발생합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Person = &#123;</span><br><span class="line">    name: <span class="string">'mike'</span>,</span><br><span class="line">    birthday: <span class="string">'222-22-22'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>제네릭</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">defaultValue: T, size: <span class="built_in">number</span></span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr: T[] = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        arr.push(defaultValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = makeArray&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> arr2 = makeArray&lt;<span class="built_in">string</span>&gt;(<span class="string">'abc'</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> arr3 = makeArray(<span class="string">'abc'</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>제네릭은 타입 정보가 동적으로 결정되며, 같은 규칙을 여러 타입에 적용할 수 있습니다.</p><p><strong>함수형 컴포넌트의 타입 정의하기</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">interface Props &#123;</span><br><span class="line">name: string;</span><br><span class="line">age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent: React.FunctionComponent&lt;Props&gt; = <span class="function"><span class="keyword">function</span>(<span class="params">&#123; name, age = <span class="number">23</span> &#125;</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;&gt;</span><br><span class="line">&lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&#123;age.substr(0)&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>클래스형 컴포넌트의 타입 정의하기</strong><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">interface Props &#123;</span><br><span class="line">containerStyle: React.CSSProperties;</span><br><span class="line">theme: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultProps = &#123;</span><br><span class="line">theme: <span class="string">'dark'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface State &#123;</span><br><span class="line">name: string;</span><br><span class="line">age: number | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">state = &#123;</span><br><span class="line">name: <span class="string">'mike'</span>,</span><br><span class="line">age: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> defaultProps = defaultProps;</span><br><span class="line">pRef = createRef&lt;HTMLParagraphElement&gt;();</span><br><span class="line">onClick1 = <span class="function">(<span class="params">e: EventObject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e.currentTarget.dataset[<span class="string">'food'</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">onClick2 = <span class="function">(<span class="params">e: React.MouseEvent&lt;HTMLButtonElement&gt;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;e.clientX&#125;</span>, <span class="subst">$&#123;e.clientY&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; containerStyle, theme &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div style=&#123;containerStyle&#125;&gt;</span><br><span class="line">&lt;p ref=&#123;<span class="keyword">this</span>.pRef&#125;&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;button data-foold="soup" onClick=&#123;this.onClick1&#125;&gt;버튼1&lt;/</span>button&gt;</span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.onClick2&#125;&gt;버튼<span class="number">2</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>참고링크</strong></p><ul><li><a href="https://overreacted.io/ko/how-are-function-components-different-from-classes/" target="_blank" rel="external">https://overreacted.io/ko/how-are-function-components-different-from-classes/</a></li></ul>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/05/typescript-basic-concepts/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바스크립트(JavaScript) 상속과 프로토타입 개념정리</title>
      <link>https://shlee1353.github.io/2019/07/05/js-prototype-inheritance/</link>
      <guid>https://shlee1353.github.io/2019/07/05/js-prototype-inheritance/</guid>
      <pubDate>Fri, 05 Jul 2019 01:46:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/js-prototype-inheritance/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트에는 클래스라는 개념대신 기존의 객체를 복사하여 새로운 객체를 생성하는 프로토타입 언어입니다. 프로토타입은 크게 두 가지
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/js-prototype-inheritance/1.png" alt=""></p><p>자바스크립트에는 클래스라는 개념대신 기존의 객체를 복사하여 새로운 객체를 생성하는 프로토타입 언어입니다. 프로토타입은 크게 두 가지로 나뉘어 집니다. 프로토타입 객체를 참조하는 prototype 속성(Prototype Object) 과 객체 멤버인 proto 속성이 참조하는 숨은 링크(Prototype Link) 입니다. 다시말해, proto (숨은링크)는 상위에서 물려받은 객체의 프로토타입에 대한 정보이며 prototype 프로퍼티는 자신을 원형으로 만들어질 새로운 객체들 즉 하위로 물려줄 연결에 대한 속성입니다.</p><p>자바스크립트에서 함수가 정의될 때 2가지가 일어납니다. 1. 해당함수에 constructor(생성자) 자격부여. 2. 해당 함수의 prototype object 생성 및 연결. 함수를 생성하면 함수 뿐만 아니라 생성된 함수와 연결되는 Prototype Object도 함께 생겨납니다. 이 객체에 접근하려면 prototype 이라는 속성을 통해 가능합니다. 기본속성으로 constructor와 proto 를 가지고 있습니다. proto 속성은 함수뿐만 아니라 모든 객체가 가지고 있습니다. 객체 생성시 조상이었던 함수의 Prototype Object를 가리킵니다.</p><h2 id="Prototype-Object"><a href="#Prototype-Object" class="headerlink" title="Prototype Object"></a>Prototype Object</h2><p>함수를 정의하면 다른 곳에 생성되는 프로토타입 객체는 자신이 다른 객체의 원형이 되는 객체입니다. 모든 객체는 프로토타입 객체에 접근할 수 있습니다. Prototype Object 는 자기 자신의 분신이며 자신을 원형으로 만들어질 다른 객체가 참조할 프로토타입이 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> joon = <span class="keyword">new</span> Person();  </span><br><span class="line"><span class="keyword">var</span> jisoo = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"인간"</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(joon.getType());   <span class="comment">// 인간  </span></span><br><span class="line"><span class="built_in">console</span>.log(jisoo.getType());  <span class="comment">// 인간</span></span><br></pre></td></tr></table></figure><p>Prototype Link 자바스크립트에서 기본 데이터 타입을 제외한 모든 것이 객체입니다. 객체가 만들어지기 위해서는 자신을 만드는 데 사용된 원형인 프로토타입 객체를 이용하여 객체를 만듭니다. 이때 만들어진 객체 안에 proto (비표준) 속성이 자신을 만들어낸 원형을 의미하는 프로토타입 객체를 참조하는 숨겨진 링크가 있습니다. 이 숨겨진 링크를 프로토타입이라고 정의합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> A = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(A);</span><br></pre></td></tr></table></figure><p>콘솔을 확인해 보면, proto 와 constructor 를 주의 깊게 봐야합니다. 해당 객체의 프로토타입은 A라는 함수 객체이며 이 객체의 생성자 역시 function A() 함수이다. 즉, new 를 사용해 만들어진 객체는 function A()를 자신의 프로토타입으로 사용해서 만들어졌습니다.</p><h2 id="상속-Inheritance"><a href="#상속-Inheritance" class="headerlink" title="상속(Inheritance)"></a>상속(Inheritance)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"annonymous"</span>;</span><br><span class="line"> <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello, my name is"</span> + <span class="keyword">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Yoda</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> obj = <span class="keyword">new</span> Person();</span><br><span class="line"> obj.name = <span class="string">"Yoda"</span>;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Yoda();</span><br><span class="line">me.sayHello();</span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> Yoda); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>초창기 자바스크립트 상속 개념은 2개의 객체가 있을 경우, 하나의 객체에서 다른 객체의 함수 사용을 목적으로한 제한적 상속방법 이였습니다. 예제 코드와 같이 new를 사용해서 obj를 만들고 리턴하는 방법입니다. 하지만, 내부를 살펴보면 me의 인스턴스는 Yoda가 아닌 Person으로 나옵니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"> name: <span class="string">"annoymous"</span>,</span><br><span class="line"> sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello, my name is"</span> + <span class="keyword">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Yoda</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"Yoda"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Yoda.prototype = person;</span><br><span class="line"><span class="keyword">var</span> yoda = <span class="keyword">new</span> Yoda();</span><br><span class="line">yoda.sayHello();</span><br><span class="line">person.sayHello();</span><br><span class="line"><span class="built_in">console</span>.log(yoda <span class="keyword">instanceof</span> Yoda); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>이러한 문제 때문에 function에서 기본적으로 제공하는 prototype을 이용한 방법이 등장 하였습니다. person을 리터럴 방식으로 생성한 뒤 객체형태로 프로퍼티와 메소드를 입력합니다. 이렇게 하면 yoda는 Yoda의 인스턴스로 true값을 반환합니다. 하지만, person이 함수형태가 아니기 때문에, instanceof Person를 이용한 부모객체 확인이 불가능합니다. 자바스크립트에서 함수가 중요한 이유는 프로토타입 속성을 제공하는 유일한 객체이기 때문입니다. 이해를 돕기위해, 앞으로 계속 등장하는 prototype과 constructor에 대해 간단히 알아 보도록 하겠습니다. <a href="http://www.nextree.co.kr/p7323/" target="_blank" rel="external">http://www.nextree.co.kr/p7323/</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Car.prototype; <span class="comment">// Object</span></span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span> : function() &#123;&#125;,</span><br><span class="line">  __proto__ : <span class="built_in">Object</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> audi = <span class="keyword">new</span> Car();</span><br><span class="line">audi = &#123;</span><br><span class="line">    __proto__ : &#123;</span><br><span class="line">        <span class="keyword">constructor</span> : function f () &#123;&#125;,</span><br><span class="line">        __proto__ : <span class="built_in">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Car라는 함수(객체)를 생성한 뒤, 내부를 살펴보면, constructor와<em>proto</em>가 있습니다. constructor는 car 함수가 생성될 때 사용된 함수객체를 나타내며, <em>proto</em>는 현재 프로토타입에 연결된 부모 객체입니다. 여기에 new를 사용하면, 함수의 prototype을 근간으로하는 신규 객체가 반환됩니다. 자바스크립트의 생성자함수에 대해 좀 더 알아보도록 하겠습니다. 객체(Object)는 Object Literal Notation을 사용해서 생성할 수도 있을 뿐 아니라, Constructor 라는 함수를 이용해서도 생성이 가능합니다. 일반적으로 new Object() 또는 Object Literal Notation을 이용해 생성한 객체들은 모두 자바스크립트 내장 함수인 Object() 라는 객체 생성자(Constructor)함수를 이용해 생성되는 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName: <span class="string">"Jason"</span>,</span><br><span class="line">  lastName: <span class="string">"Bourne"</span>,</span><br><span class="line">  age: <span class="number">25</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor); <span class="comment">//function Object() </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor); <span class="comment">//function Object() </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor == person2.constructor); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"><span class="keyword">var</span> number = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"String"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array.constructor); <span class="comment">//function Array()</span></span><br><span class="line"><span class="built_in">console</span>.log(number.constructor); <span class="comment">//function Number()</span></span><br><span class="line"><span class="built_in">console</span>.log(bool.constructor); <span class="comment">//function Boolean()</span></span><br><span class="line"><span class="built_in">console</span>.log(str.constructor); <span class="comment">//function String()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Name : "</span> + firstName + <span class="string">" "</span> + lastName + <span class="string">"\nAge : "</span> + age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Jason"</span>, <span class="string">"Bourne"</span>, <span class="number">33</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Jenny"</span>, <span class="string">"Laurence"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor); <span class="comment">//function Person</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor); <span class="comment">//function Person</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"annoymous"</span>;</span><br><span class="line"> <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello, my name is"</span> + <span class="keyword">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Yoda</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"Yoda"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Yoda.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> yoda = <span class="keyword">new</span> Yoda();</span><br><span class="line">yoda.sayHello();</span><br><span class="line"><span class="built_in">console</span>.log(yoda <span class="keyword">instanceof</span> Yoda); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(yoda <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>다시 상속으로 돌아와서, prototype을 new로 생성하여 Yoda.prototype으로 지정하는 방법이 있습니다. 이럴경우, yoda는 Yoda와 Person의 인스턴스로 확인이 가능합니다. 하지만, 여기에도 문제가 있습니다. 실제 생성자는 Yoda임에도 불구하고 내부 constructor은 일치하지 않습니다. 그럼에도 불구하고, instanceof를 확인해보면 둘다 true가 나오는데 이러한 이유는 instanceof는 prototype을 기반으로 작동하기 때문입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> F.prototype = o;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Constructor를 제대로 연결하기 위해 Object.create()가 표준으로 등장하였으며, IE9 이상부터 사용이 가능합니다. 이 함수는 prototype을 인자로 받아 기본함수 F의 prototype()으로 설정을 한 뒤 new 명령어를 통해 새로운 객체를 리턴합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"annoymous"</span>;</span><br><span class="line"> <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello, my name is"</span> + <span class="keyword">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Yoda</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"Yoda"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Yoda.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Yoda.prototype.constructor = Yoda;</span><br><span class="line"><span class="keyword">var</span> yoda = <span class="keyword">new</span> Yoda();</span><br><span class="line">yoda.sayHello();</span><br></pre></td></tr></table></figure><p>우선 Object.create()를 사용하여 Person.prototype을 상속받습니다. 다음으로, constructor를 Yoda 로 재선언 해준 뒤, call()를 사용하여 조상 메소드에 접근이 가능합니다. 결국, 자바스크립트는 상속은 생성자와 프로토타입에 기반을 두고 있습니다. ES6 에서는 클래스를 사용하여 이를 간단히 표현할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line"> &#125;</span><br><span class="line"> printProfile() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 문법으로 작성한 위 내용은 결국 아래와 같습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.printProfile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6에서 클래스 상속 구현은 extends 절과 super 키워드를 사용하여 구현합니다. extends 절은 클래스가 다른 생성자의 정적/비정적 프로퍼티를 상속 가능하게 합니다. super 키워드는 클래스 constructor 메소드에서 부모 생성자를 호출하거나, 클래스 메소드 내부에서 부모 생성자의 정적/비정적 메소드를 참조할 때 사용합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span> (name, type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getType () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, <span class="string">'car'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'It is a car: '</span> + <span class="keyword">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car(<span class="string">'Tesla'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car.getName()); <span class="comment">// It is a car: Tesla</span></span><br><span class="line"><span class="built_in">console</span>.log(car.getType()); <span class="comment">// car</span></span><br></pre></td></tr></table></figure><p>상속의 예시를 살펴보면, Vehicle 의 프로퍼티값으로 name과 type이 있으며, getName(), getType() 두 메소드를 가지고 있습니다. Car는 extends와 super()를 사용하여 Vehicle를 상속받아 car라는 인스턴스를 생성하였습니다. 이 과정에서 getName()은 Car 내부에서 다시 정의가 되었습니다. 마지막에 생성된 car는 Vehicle과 Car의 메소드에 접근할 수 있습니다. 자바스크립트 상속과정을 설명하면서 this가 많이 나왔는데요, 이것도 간단히 정리해보도록 하겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">'hello'</span>; </span><br><span class="line">&#125; </span><br><span class="line">alert(greeting); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>자바스크립트에서 함수는 위와같이 유호범위(scope)를 생성합니다. 현재 코드에서는, 외부에서 접근이 불가능합니다. 컨텍스트(context)는 내부에서 코드가 돌아가는 객체를 의미합니다. 이때, this를 사용해서 컨텍스트를 참조할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function 내부 컨텍스트</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); </span><br><span class="line">&#125;;</span><br><span class="line">f(); <span class="comment">// window(전역객체)를 가리킴</span></span><br><span class="line"><span class="comment">// 메소드 내부 컨텍스트</span></span><br><span class="line"><span class="keyword">var</span> oj = &#123;</span><br><span class="line">    method : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">oj.method(); <span class="comment">// 메소드를 담은 객체를 가리킴</span></span><br><span class="line"><span class="comment">// 메소드 내부에 중첩된 함수의 컨텍스트</span></span><br><span class="line"><span class="keyword">var</span> oj = &#123;</span><br><span class="line">    method : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// window(전역객체)를 가리킴</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/05/js-prototype-inheritance/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트(React) 순수함수 (HOC 개념정리)</title>
      <link>https://shlee1353.github.io/2019/07/04/higher-order-components/</link>
      <guid>https://shlee1353.github.io/2019/07/04/higher-order-components/</guid>
      <pubDate>Thu, 04 Jul 2019 10:45:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/higher-order-components/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Higher-Order Components HOC는 컴포넌트 로직을 재사용하기 위한 리액트의 고급기술입니다. 함수로서 컴포넌트를 인자
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/higher-order-components/1.png" alt=""></p><p>Higher-Order Components HOC는 컴포넌트 로직을 재사용하기 위한 리액트의 고급기술입니다. 함수로서 컴포넌트를 인자로 받아 새로운 컴포넌트를 리턴합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>기존 컴포넌트가 props를 받아 UI를 만들었다면, HOC는 컴포넌트를 다른 컴포넌트로 바꿉니다. HOC는 Redux’s connect, Realy’s createFragmentContainer에서 흔히 사용하고 있습니다. 리액트에서 컴포넌트는 코드 재사용을 위한 매우 중요한 유닛입니다.</p><p><a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="external">https://reactjs.org/docs/higher-order-components.html</a></p><p>ComponentList와 BlogPost는 동일하지 않지만, 같은 로직을 가지고 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addChangeListener() -&gt; handleChange() -&gt; removeChangeListener()</span><br></pre></td></tr></table></figure><p>앱 전체적으로 봤을 때 이러한 로직은 자주 사용되는 패턴입니다. 이러한 로직을 하나의 장소에서 관리하고 여러 컴포넌트에서 사용할 수 있도록 추상화작업이 필요합니다. 이럴때 HOC가 필요합니다. DataSource를 구독하고 있는 CommentList, BlogPost 컴포넌트를 제작할 수 있는 함수를 만들어 보도록 하겠습니다. 이 함수는 인자로 데이터를 prop로 받을 수 있는 자식 컴포넌트를 받습니다. 이 함수를 withSubscription 이라고 부르도록 하겠습니다.</p><p><strong>첫번째 파라미터는 wrapped 컴포넌트이며, 두 번째 파라미터로 DataSource와 현재 props값을 받습니다.</strong></p><p>CommentListWithSubscription과 BlogPostWithSubscription이 랜더되면, CommentList와 BlogPost는 data prop로 전달됩니다. 이 값에는 DataSource에서 받은 현재값도 포함됩니다. HOC는 주입된 컴포넌트를 수정하지도 않으며 inheritance를 사용하지도 않습니다. wrapped 컴포넌트는 새로운 props, data는 물론 부모 container의 모든 props를 받습니다. Wrapped component는 어떻게 왜 데이터가 사용되는지, 어디서 오는지 고민할 필요가 없습니다.</p><p>리액트의 HOC의 구조를 보면 고차함수가 생각납니다. 고차함수를 만족시키는 조건으로는, 첫째, 함수를 파라미터로 전달 받는 함수, 둘째, 함수를 리턴하는 함수입니다.</p><h2 id="어디에-쓰이나"><a href="#어디에-쓰이나" class="headerlink" title="어디에 쓰이나?"></a>어디에 쓰이나?</h2><ol><li>비즈니스 로직을 담당하는 컴포넌트와 디스플레이를 담당하는 컴포넌트를 분리하여 사용할때</li><li>로딩 중 화면표시, 유저 인증 로직 처리 (컴포넌트 내에서 권한 체크나 로그인 상태를 체크인 하기 보다는 인증로직을 HOC로 분리)</li></ol><p>아래와 같이 Button, Label 컴포넌트가 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button&gt;button&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line">        &lt;Label&gt;label&lt;<span class="regexp">/Label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> &lt;button&gt;&#123;props.children&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">class Label extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return(</span></span><br><span class="line"><span class="regexp">      &lt;label&gt;&#123;this.props.children&#125;&lt;/</span>label&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>HOC 컴포넌트는 컴포넌트를 인자로 받아서 새로운 컴포넌트를 리턴합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">InnerComponent</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;InnerComponent /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>완성코드</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">InnerComponent</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  update()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;InnerComponent </span><br><span class="line">        &#123;...this.props&#125;</span><br><span class="line">        &#123;...this.state&#125;</span><br><span class="line">        update=&#123;<span class="keyword">this</span>.update.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button&gt;button&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line">        &lt;LabelHOC&gt;label&lt;<span class="regexp">/LabelHOC&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Button = HOC(<span class="function">(<span class="params">props</span>) =&gt;</span> </span><br><span class="line">  &lt;button onClick=&#123;props.update&#125;&gt;&#123;props.children&#125; - &#123;props.count&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">class Label extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return(</span></span><br><span class="line"><span class="regexp">      &lt;label onMouseMove=&#123;this.props.update&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &#123;this.props.children&#125; - &#123;this.props.count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>label&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LabelHOC = HOC(Label)</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>실무에서 storybook 컴포넌트를 정리하면서 HOC를 사용했습니다. 예를들어, true, false에 따라 열리고 닫히는 모달팝업이 여러개 있을 경우, 열고/닫기 로직을 HOC로 만들어 놓고 이를 여러개의 모달 컴포넌트에 적용하였습니다. 특별히, storybook 내부에서는 state관리가 직관적으로 되지않기 때문에 이를 해결하는 방법으로 HOC사용 및 플러그인이 있습니다.</p>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/04/higher-order-components/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트(React) 라이프사이클 v16.3 간단정리</title>
      <link>https://shlee1353.github.io/2019/07/04/react-component-lifecycle/</link>
      <guid>https://shlee1353.github.io/2019/07/04/react-component-lifecycle/</guid>
      <pubDate>Thu, 04 Jul 2019 10:11:50 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/react-component-lifecycle/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;리액트-라이프-사이클&quot;&gt;&lt;a href=&quot;#리액트-라이프-사이클&quot; class=&quot;headerlink&quot; title=&quot;리액트 라
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/react-component-lifecycle/1.png" alt=""></p><h1 id="리액트-라이프-사이클"><a href="#리액트-라이프-사이클" class="headerlink" title="리액트 라이프 사이클"></a>리액트 라이프 사이클</h1><p>리액트버전 16.3에서 새로운 라이프 사이클 2개가 소개되었습니다. getDerivedStateFromProps, getSnapshotBeforeUpdate 이며 기존에 사용하던componentWillMount, componentWillUpdate, componentWillReceiveProps 는 점차 지원이 중단되어 버전 17에서는 완전히 삭제될 예정이라고 합니다.</p><p>컴포넌트 라이프사이클 초기 화면 로딩시:</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><p>첫 화면 랜더링 후 props가 바뀔경우:</p><ul><li>getDerivedStateFromProps</li><li>shouldComponentUpdate (if return false일 경우 종료, true면 랜더진행)</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><p>state가 바뀔 경우에는 바로 shouldComponentUpdate 부터 라이프사이클이 진행 됩니다. 라이프 사이클의 기본적인 사용방법과 각각의 라이프 사이클에 대해 알아 보도록 하겠습니다.</p><h2 id="1-Initializing-state"><a href="#1-Initializing-state" class="headerlink" title="1. Initializing state"></a>1. Initializing state</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    currentColor: <span class="keyword">this</span>.props.defaultColor,</span><br><span class="line">    palette: <span class="string">'rgb'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state값 초기화 시, constructor 또는 state 객체에 바로 추가하면 됩니다.</p><h2 id="2-Fetching-external-data"><a href="#2-Fetching-external-data" class="headerlink" title="2. Fetching external data"></a>2. Fetching external data</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._asyncRequest = asyncLoadData().then(</span><br><span class="line">      externalData =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>._asyncRequest = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;externalData&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>외부 데이터를 추가 시 componentDidMount에 추가합니다.</p><h2 id="3-Adding-event-listeners"><a href="#3-Adding-event-listeners" class="headerlink" title="3. Adding event listeners"></a>3. Adding event listeners</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Event listeners are only safe to add after mount,</span></span><br><span class="line">    <span class="comment">// So they won't leak if mount is interrupted or errors.</span></span><br><span class="line">    <span class="keyword">this</span>.props.dataSource.subscribe(</span><br><span class="line">      <span class="keyword">this</span>.handleSubscriptionChange</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// External values could change between render and mount,</span></span><br><span class="line">    <span class="comment">// In some cases it may be important to handle this case.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>.state.subscribedValue !==</span><br><span class="line">      <span class="keyword">this</span>.props.dataSource.value</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        subscribedValue: <span class="keyword">this</span>.props.dataSource.value,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>이벤트 리스너 또한 componentDidMount에 추가합니다.</p><h2 id="4-Updating-state-based-on-props"><a href="#4-Updating-state-based-on-props" class="headerlink" title="4. Updating state based on props"></a>4. Updating state based on props</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.currentRow !== state.lastRow) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        isScrollingDown: props.currentRow &gt; state.lastRow,</span><br><span class="line">        lastRow: props.currentRow,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>state의 변화가 필요하면, state 객체를 반환합니다. 이는 마치, this.setState({stateName: value})와 같습니다. state 변화가 필요없을 경우는 null을 반환합니다.</p><h2 id="5-Invoking-external-callbacks"><a href="#5-Invoking-external-callbacks" class="headerlink" title="5. Invoking external callbacks"></a>5. Invoking external callbacks</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>.state.someStatefulValue !==</span><br><span class="line">      prevState.someStatefulValue</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.onChange(<span class="keyword">this</span>.state.someStatefulValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>constructor()</strong></p><p>이 메소드는 새로운 객체가 생성될 때 마다 호출됩니다. super(props)은 부모 클래스의 생성자를 호출하며 this.props 로 접근이 가능합니다. 또한, 콜백으로 전달될 함수들을 바인딩 할 때도 사용됩니다. this.setState() 또는 Ajax 요청을 사용하시면 안됩니다. (componentDidMount()에서 사용)</p><p><strong>static getDerivedStateFromProps()</strong></p><p>이 메소드는 컴포넌트 초기화 또는 새로운 props를 받았을 때 일어납니다. 인스턴스가 아닌 클래스로 존재합니다. 그렇기 때문에 this 키워드 접근이 불가능합니다. this.setState() 사용 대신 state를 업데이트 하기 위한 객체를 리턴하며 업데이트가 필요없을 경우 null값을 리턴합니다. 오로지 변화가 생긴 state만 리턴하고 나머지는 유지됩니다. this.setState()는 이 메소드를 호출하지 못합니다.</p><p><strong>houldComponentUpdate()</strong></p><p>새로운 렌더링 과정이 필요 없을 경우 라이프사이클을 빠져나올 수 있습니다. 리엑트는 기본적으로 깊은 비교를 하지 않습니다. 그렇기 때문에 props, state가 업데이트 될 경우 리렌더링이 필요하다고 생각합니다.</p><p><strong>render()</strong></p><p>이 메소드가 호출되면 this.props와 this.state가 분석되며 리액트 엘리먼트를 리턴합니다. render() 메소드는 state를 변경하면 안되며 브라우저와 직접적으로 상호작용하면 안됩니다. 브라우저와 연동하려면 componentDidMount()안에서 하면 됩니다. shouldComponentUpdate()가 false를 리턴할 경우 발생하지 않습니다.</p><p><strong>componentDidMount()</strong></p><p>이 메소드는 전체 라이프사이클에서 한 번만 호출됩니다. 데이터와 관련된 로직을 실행하기에 적합합니다. componentDidupdate()는 prevProps, prevState, snapshot을 파라미터로 가질 수 있습니다. 이 외에도 componentWillUnmount(), componentDidCatch()가 있습니다.</p>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/04/react-component-lifecycle/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바스크립트(JavaScript) this 바인딩 기본개념</title>
      <link>https://shlee1353.github.io/2019/07/04/js-this-bind/</link>
      <guid>https://shlee1353.github.io/2019/07/04/js-this-bind/</guid>
      <pubDate>Thu, 04 Jul 2019 07:54:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/image/js-this-bind/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트에서 this 키워드는 좀 특별합니다. ES5에서는 bind 메소드를 사용해서 this 키워드를 설정 할 수 있으며, ES2015에서는 arr
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/image/js-this-bind/1.png" alt=""></p><p>자바스크립트에서 this 키워드는 좀 특별합니다. ES5에서는 bind 메소드를 사용해서 this 키워드를 설정 할 수 있으며, ES2015에서는 arrow functions 을 사용해서 고유의 this 키워드를바인딩 할 수 있습니다. (렉시컬 컨텍스트 안에 this를 유지)</p><h2 id="Global-context"><a href="#Global-context" class="headerlink" title="Global context"></a>Global context</h2><p>함수 밖, 글로벌 실행 컨텍스트에서 this는 글로벌 객체를 가르킵니다(strict mode or not)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">a = <span class="number">37</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">this</span>.b = <span class="string">"MDN"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// "MDN" </span></span><br><span class="line"><span class="built_in">console</span>.log(b)         <span class="comment">// "MDN"</span></span><br></pre></td></tr></table></figure><h2 id="Function-context"><a href="#Function-context" class="headerlink" title="Function context"></a>Function context</h2><p>함수 내부에서 this는 함수 호출에 따라 달라집니다. 일반모드에서 함수 내부의 this는 글로벌을 가르키지만, strict mode에서는 undefined이 출력됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-strict mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In a browser:</span></span><br><span class="line">f1() === <span class="built_in">window</span>; <span class="comment">// true </span></span><br><span class="line"><span class="comment">// In Node:</span></span><br><span class="line">f1() === global; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// strict mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>; <span class="comment">// see strict mode</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>call, apply 메소드를 사용해서 this 값을 다른 컨텍스트로 전달 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Custom'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'Global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsThis</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line">whatsThis();          <span class="comment">// 'Global'</span></span><br><span class="line">whatsThis.call(obj);  <span class="comment">// 'Custom'</span></span><br><span class="line">whatsThis.apply(obj); <span class="comment">// 'Custom'</span></span><br></pre></td></tr></table></figure><p>call과 apply의 차이점은 두 번째 파라미터에 배열값을 전달 할 수 있는가 없는가 입니다. 첫 번째로 전달되는 this는 객체로, 숫자나 문자열이 전달 되어도 ToObject로 인해 객체로 변환됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 16</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure><p>f.bind(someObject)은 f와 같은 바디와 스코프를 가진 새로운 함수를 생성합니다. 하지만. this는 본래 함수에서 발생합니다. bind는 중복 설정되지 않고 한 번만 가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>: <span class="string">'azerty'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>: <span class="string">'yoo'</span>&#125;); <span class="comment">// bind only works once!</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">37</span>, <span class="attr">f</span>: f, <span class="attr">g</span>: g, <span class="attr">h</span>: h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g(), o.h()); <span class="comment">// 37, azerty, azerty</span></span><br></pre></td></tr></table></figure><p>arrow 함수에서 this 는 렉시컬 컨텍스트와 연결됩니다. 글로벌 코드에서는 글로벌 객체와 연결됩니다. obj.bar 의 익명함수1 안에 arrow 함수로 선언된 익명함수2의 this는 익명함수1의 this와 연결되어 있고, 이 this는 다시 obj 객체와 연결되어 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예시 1</span></span><br><span class="line"><span class="keyword">var</span> globalObject = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === globalObject); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 예시 2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn = obj.bar();</span><br><span class="line"><span class="built_in">console</span>.log(fn() === obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>함수가 객체의 메소드로 호출되면, 이것의 this는 메소드를 호출한 객체와 연결됩니다. o.f()가 호출되면, 함수 내부의 this는 o 객체가 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  prop: <span class="number">37</span>,</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></span><br></pre></td></tr></table></figure><p>프로토타입 체인에서도 this는 함수가 호출된 객체에 지정이 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b; &#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>수정된 프로그램의 영향이 전체 소스에 퍼지지 않도록 getter, setter 사용합니다. 예를들어</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//기존방법</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 개선방법</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'num'</span>, &#123;<span class="attr">value</span>:<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure><p>defineProperty 함수에서 가장 중요한 것은 세번째 옵션으로 들어가는 인자입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">value : 속성값</span><br><span class="line">writable : 속성값 변경 여부</span><br><span class="line">configurabl e: 속성의 옵션값 변경 여부</span><br><span class="line">enumerable : <span class="keyword">for</span> <span class="keyword">in</span> 반복만 사용 가능 여부</span><br><span class="line">get : value, writable 과 함꼐 사용 못함</span><br><span class="line">set : value, writable 과 함꼐 사용 못함</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 원 = &#123;&#125;;</span><br><span class="line">원._반지름 = <span class="number">0</span>;   <span class="comment">// 겟터 셋터 대상 및 초기값 지정</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( 원, <span class="string">'반지름'</span>, &#123; </span><br><span class="line"> get : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)   </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._반지름; &#125;,</span><br><span class="line"> set : <span class="function"><span class="keyword">function</span>(<span class="params">값</span>) </span>&#123; <span class="keyword">this</span>._반지름 = 값;    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 사용예 </span></span><br><span class="line">원.반지름 = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'원.반지름 = '</span>, 원.반지름);</span><br></pre></td></tr></table></figure><p>defineProperty없이 getter, setter 함수에 대해 알아보도록 하겠습니다. 아래처럼 person 객체에 get, set 함수를 정의해서 사용가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    firstName: <span class="string">'Jimmy'</span>,</span><br><span class="line">    lastName: <span class="string">'Smith'</span>,</span><br><span class="line">    get fullName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    set fullName (name) &#123;</span><br><span class="line">        <span class="keyword">var</span> words = name.toString().split(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.fullName = <span class="string">'Jack Franklin'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.firstName); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(person.lastName) <span class="comment">// Franklin</span></span><br></pre></td></tr></table></figure><p>defineProperty에 의해 생성된 sum은 호출시 this가 o 객체를 향하고 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + <span class="keyword">this</span>.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">  get average() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.a + <span class="keyword">this</span>.b + <span class="keyword">this</span>.c) / <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'sum'</span>, &#123;</span><br><span class="line">    get: sum, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.average, o.sum); <span class="comment">// 2, 6</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://shlee1353.github.io/2019/07/04/js-this-bind/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
